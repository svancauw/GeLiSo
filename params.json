{"name":"GeLiSo - Gecode in common Lisp using Sockets","body":"### Introduction\r\n\r\nThis project allows working with the constraint programming C++ library Gecode inside the Common Lisp language (especially the Lispworks implementation). For this purpose, sockets are used to communicate between a Lisp and a C++ application.\r\n\r\n### Current status\r\n\r\nCurrently, it is only possible to use the relation variables (and associated constraints). (see http://ggutierrez.github.com/cprelmaster/index.html)\r\n\r\n### Download\r\n\r\nTo get the latest version, please use git as follows (`$` represents here the prompt of your terminal):\r\n\r\n```\r\n$ git clone https://github.com/svancauw/GeLiSo.git\r\n```\r\n\r\n### Installation\r\n\r\nInstallation requires first the installation of the CPRel package. Please refer to the associated installation instructions : http://ggutierrez.github.com/cprelmaster/install.html\r\n\r\nAfter having successfully installed the CPRel package, follow the instructions below. `/Path/To/GeLiSo` is here the path of the cloned directory.\r\n\r\n1. Create a directory where GeLiSo will be built (here `/Path/To/Build-GeLiSo/`). It is advised that this directory is not a subdirectory of `/Path/To/GeLiSo`.\r\n```\r\n$ mkdir /Path/To/Build-GeLiSo/\r\n$ cd /Path/To/Build-GeLiSo/\r\n``` \r\n\r\n2. Configure and build. Depending on where the different dependencies (Gecode, CPRel, gcc, boost) are installed on your machine, you may have to add some cmake options to get a correct configuration. In the code below, `(options)` represents the different options you have to pass.\r\n```\r\n$ cmake (options) /Path/To/GeLiSo/\r\n$ make\r\n``` \r\nThe options that could have to be used are the following :\r\n\r\n* -DCMAKE_C_COMPILER=/Path/To/Gcc/Compiler/gcc \r\n* -DCMAKE_CXX_COMPILER=/Path/To/G++/Compiler/g++ \r\n* -DCMAKE_PREFIX_PATH=\"/Path/To/Gecode/Installation/;/Path/To/CPRel/Installation/\" \r\n* -DBOOST_ROOT=/Path/To/Boost/Installation/\r\n* -DCMAKE_CXX_FLAGS=\"-I/Path/To/Gecode/Installation/include -I/Path/To/CPRel/Installation/include/ -L/Path/To/Gecode/Installation/lib/\"\r\n* -DCMAKE_C_FLAGS=\"-I/Path/To/Gecode/Installation/include -I/Path/To/CPRel/Installation/include/ -L/Path/To/Gecode/Installation/lib/\"\r\n\r\nwhere `/Path/To/Gcc/Compiler/`, `/Path/To/G++/Compiler/`, `/Path/To/Gecode/Installation/`, `/Path/To/CPRel/Installation/` and `/Path/To/Boost/Installation/` represents respectively the (full) path where gcc, g++, Gecode, CPRel and Boost have been installed.\r\n\r\n### Quick start\r\n\r\n1. Currently, before each execution, the C++ application must be launched. To do so, use the terminal:\r\n```\r\n$ /Path/To/Build-GeLiSo/bin/gelisoexec\r\n```\r\n\r\n2. Then, from a Common Lisp interpreter (Lispworks for instance, as it is the only one that has been tested (http://www.lispworks.com/)), load the file `load.lisp` of the  \r\n/Path/To/GeLiSo/lispsources/ directory :\r\n```\r\n$ (load \"/Path/To/GeLiSo/lispsources/load.lisp\")\r\n```\r\n\r\nThat's it ! Now Gecode can be used from a Common Lisp interpreter.\r\n\r\n### Example\r\n\r\nHere is a small example to test GeLiSo. Notice we do not use local variables but it should be done where it can be.\r\n\r\n1. Establish the connection with the C++ application and create a GecodeManager object. This object is used to send the messages to the application.\r\n```\r\n(setq endpoint_receive '(\"127.0.0.1\" 2222))\r\n(setq endpoint_send '(\"127.0.0.1\" 3333))\r\n;create the gecode manager and connect the sockets\r\n(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))\r\n```\r\n\r\n2. Create a Gecode space sp\r\n```\r\n(setq sp (newSpace gm))\r\n```\r\n\r\n3. Declare the decision variables varA and varB.\r\n```\r\n;;varA\r\n;empty ternary relation value (ground relation) grA\r\n(setq grA (newGRelation gm 3))\r\n;add the tuple <1 2 3> to grA\r\n(GRelation-AddTuple gm grA (newTuple gm '(1 2 3)))\r\n;declare the varA decision variable\t\t\r\n(setq varA (newCPRelVar gm sp grA grA))\r\n;;varB\r\n;empty ternary relation value (ground relation) glbB\r\n(setq glbB (newGRelation gm 3))\r\n;empty ternary relation value (ground relation) lubB\r\n(setq lubB (newGRelation gm 3))\r\n;add the tuples <1 2 3> and <4 5 6> to lubB\r\n(GRelation-AddTuple gm lubB (newTuple gm '(1 2 3)))\r\n(GRelation-AddTuple gm lubB (newTuple gm '(4 5 6)))\r\n;declare the varA decision variable\t\t\r\n(setq varB (newCPRelVar gm sp glbB lubB))\t\t\r\n```\r\n\r\n4. It is possible to print the Gecode Space sp\r\n```\t\t\r\n(printSpace gm sp)\r\n```\t\t\r\n\t\t\r\n5. Impose a constraint on the decision variables. For instance, an equality constraint :\r\n```\r\n(equalConstraint gm sp varA varB)\t\t\r\n```\r\n\r\n6. Add a brancher on decision variable varB\r\n```\r\n(branch gm sp varB)\r\n```\r\n\t\t\r\n7. Define a Gecode search engine. The argument 0 means Depth-First Search.\r\n```\r\n(setq se (newSearchEngine gm sp 0))\r\n```\t\r\n\r\n8. Get the next solution space.\r\n```\r\n(setq sol1 (nextSolution gm sp se))\r\n```\t\r\n\r\n9. If there is a solution space, print it.\r\n```\t\t\r\n(if (string/= sol1 \"0\")\r\n\t(progn \r\n\t\t(printSpace gm sol1)\t\r\n\t)\r\n)\r\n```\t\t\r\n10. Close the connection to the C++ application. \r\n```\t\t\t\t\t\t\r\n(quitGecode gm)\r\n```\t\t\r\n\r\n\r\nFor more information, please consult the file `GecodeManager.lisp` in the `/Path/To/GeLiSo/lispsources` directory.\r\n\r\nSome tests examples can be found in the file `test.lisp` in the `/Path/To/GeLiSo/lispsources/tests/` directory.\r\n\r\n\r\n### Contact\r\n\r\nAny comments or questions are welcome. You can either use the development site (https://github.com/svancauw/GeLiSo) or \r\nthe mail address sascha.vancauwelaert **at** gmail.com .\r\n\r\n### Authors\r\n\r\n* Sascha Van Cauwelaert (@svancauw) \r\n* Gustavo Guti√©rrez (@ggutierrez)\r\n","tagline":"","note":"Don't delete this file! It's used internally to help with page regeneration.","google":""}