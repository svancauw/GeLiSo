; OM File Header - Saved 2012/04/25 16:45:30
; (6.050003 :patc (om-make-point 64 60) (om-make-point 0 0) (om-make-point 640 752) "" 183 0 "2012/02/15 17:07:58" "2012/02/19 22:45:41")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "patchrel - intro " (quote ((om-load-boxcall (quote genfun) "EXPORT-MUSICXML" (quote export-musicxml) (quote ((om-load-inputfun (quote input-funbox) "a VOICE or POLY object" "SELF" nil))) (om-make-point 646 771) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 475 311) (om-make-point 21 30) 2 "2" nil) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 156 340) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "LIST 9" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 1095 522) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 8" (quote list) (quote nil) (om-make-point 1226 346) (om-make-point 21 30) 2 "2" nil) (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 1171 359) (om-make-point 28 30) 17 "17" nil) (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 1092 363) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 1025 355) (om-make-point 28 30) 33 "33" nil) (om-load-boxcall (quote genfun) "PGMOUT 2" (quote pgmout) (quote ((om-load-inputfun (quote input-funbox) "program number" "PROGM" 35) (om-load-inputfun (quote input-funbox) "MIDI channel(s)" "CHANS" 1))) (om-make-point 1180 434) nil nil nil nil 1) (om-load-boxcall (quote genfun) "PGMOUT" (quote pgmout) (quote ((om-load-inputfun (quote input-funbox) "program number" "PROGM" 50) (om-load-inputfun (quote input-funbox) "MIDI channel(s)" "CHANS" 1))) (om-make-point 1042 405) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "LIST 2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 134 607) nil nil nil nil 1) (om-load-editor-box1 "MULTI-SEQ" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 71 685) (om-make-point 130 65) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6700) (6700) (6700) (6700) (7200) (7200) (7200) (7200) (6700) (6700) (6700) (7200) (7200) (7200) (6700) (7200))) :lonset (quote (1000 1500 2000 2500 6500 7000 7500 8000 500 1000 1500 2000 1500 500 3000 2000 6500 7000 7500 6500 7000 7500 8000 8000 10500)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6700) (6700) (6700) (7200) (7200) (6700) (7200) (7200) (6700) (6700) (6700) (6700) (7200) (7200) (7200) (7200))) :lonset (quote (3000 3500 4000 4500 8500 9000 9500 10000 2500 3000 3500 3500 2500 4000 5000 4000 8500 9000 9500 10000 8500 9000 9500 10000 10500)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 0) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1 1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote g) (quote g)) 24 2)) nil nil nil nil) (om-load-boxcall (quote lispfun) "LIST" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 266 789) nil nil "&" nil 1) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 579 268) nil nil "&" nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 302 343) nil nil "&" nil 1) (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 119 307) nil nil "&" nil 1) (om-load-boxcall (quote abstraction) "rel as score (without duration) 3" (om-load-patch-abs1 "rel as score (without duration)" (quote ((om-load-boxin "channel" 1 (om-make-point 449 45) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$$$$(setq scoreParam (getScoreParamFromSol scoreRel))$$;(print scoreParam)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 204 245) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 362 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 273 317) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 302 279) (om-make-point 35 30) 100 "100" nil))) (quote ((9 0 1 1 nil 0) (7 0 1 2 nil 0) (0 0 1 6 nil 0) (1 0 3 0 nil 0) (2 0 4 0 nil 0) (4 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (8 0 7 1 nil 0) (5 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 0 0) (om-make-point 1280 752)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 6 382) nil nil "&" "rel as score (without duration)") (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 56 493) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6700) (6700) (6700) (6700) (7200) (7200) (7200) (7200) (6700) (6700) (6700) (7200) (7200) (7200) (6700) (7200))) :lonset (quote (1000 1500 2000 2500 6500 7000 7500 8000 500 1000 1500 2000 1500 500 3000 2000 6500 7000 7500 6500 7000 7500 8000 8000 8000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 0) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxcall (quote abstraction) "rel as score (without duration) 2" (om-load-patch-abs1 "rel as score (without duration)" (quote ((om-load-boxin "channel" 1 (om-make-point 475 52) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 365 409) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$$$$(setq scoreParam (getScoreParamFromSol scoreRel))$$;(print scoreParam)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 204 245) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 362 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 273 317) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 302 279) (om-make-point 35 30) 100 "100" nil))) (quote ((9 0 1 1 nil 0) (7 0 1 2 nil 0) (0 0 1 6 nil 0) (1 0 3 0 nil 0) (2 0 4 0 nil 0) (4 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (8 0 7 1 nil 0) (5 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 0 0) (om-make-point 1280 752)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 300 365) nil nil "&" "rel as score (without duration)") (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 345 496) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6700) (6700) (6700) (7200) (7200) (6700) (7200) (7200) (6700) (6700) (6700) (6700) (7200) (7200) (7200) (7200))) :lonset (quote (3000 3500 4000 4500 8500 9000 9500 10000 2500 3000 3500 3500 2500 4000 5000 4000 8500 9000 9500 10000 8500 9000 9500 10000 10500)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2) (2))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 5 197) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 669 500) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6700) (6700) (6700) (6700) (6700) (6700) (6700) (7200) (7200) (7200) (7200) (7200) (7200) (6700) (6700) (6700) (6700) (7200) (7200) (7200) (7200) (7200) (6700) (6700) (6700) (6700) (6700) (7200) (7200) (7200) (7200) (7200))) :lonset (quote (1000 1500 2000 2500 3000 3500 4000 4500 6500 7000 7500 8000 8500 9000 9500 10000 500 1000 1500 2000 2500 3000 3500 1500 500 2000 2500 3000 3500 4000 6500 7000 7500 5000 4000 6500 7000 7500 8000 8500 9000 9500 10000 8000 8500 9000 9500 10000 10500)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 0) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxcall (quote abstraction) "rel as score (without duration)" (om-load-patch-abs1 "rel as score (without duration)" (quote ((om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 280 403) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$$$$(setq scoreParam (getScoreParamFromSol scoreRel))$$;(print scoreParam)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 204 245) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 362 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 273 317) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 302 279) (om-make-point 35 30) 100 "100" nil))) (quote ((8 0 0 1 nil 0) (6 0 0 2 nil 0) (0 0 2 0 nil 0) (1 0 3 0 nil 0) (3 0 4 0 nil 0) (3 0 5 0 nil 0) (5 0 6 0 nil 0) (7 0 6 1 nil 0) (4 0 8 0 nil 0) (9 0 8 1 nil 0))) 6.050003 nil "" (om-make-point 0 0) (om-make-point 1280 752)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 623 301) nil nil "&" "rel as score (without duration)") (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 234 892) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 133 28) nil (list nil) "&" "create Gecode manager") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 379 120) nil (list "9b24ddf5-e6ce-47c4-817c-336fd9a9ae7b") "&" "create space") (om-load-boxcall (quote abstraction) "intro" (om-load-lisp-abspatch "intro" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp) $$  (let ($        ;permDesc$        (permDesc '((0 1)))$	;ground relations$        ;(glbV0 (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((60 1) (60 2) (60 3) (60 4) (67 5) (67 6) (67 7) (67 8) (72 9) (72 10) (72 11) (72 12) (60 13) (60 14) (60 15) (60 16)))))$        (glbV0 (newGRelation gm 2))$        ;(glbV0 (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((60 1) (67 5) (72 9) (60 13)))))$        (glbScore (newGRelation gm 2))$        (glbScoreOff (newGRelation gm 3))$        ;(glbScoreOffPlus (newGRelation gm 4))$        (lubScore (first (createBoundedFullGroundRelation gm '((60 72) (1 20)))))$        (lubPermutScore (first (createBoundedFullGroundRelation gm '((1 20) (60 72)))))$        (lubScoreOff (first (createBoundedFullGroundRelation gm '((60 72) (1 20) (4 4)))))$        (lubOff (first (createBoundedFullGroundRelation gm '((4 4)))))$        (plusRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm (createBoundedPlus '(0 20) '(0 20)))))$        (lubPP (first (createBoundedFullGroundRelation gm '((60 72) (60 72)))))$        ;(consonantRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((60 72) (72 60) (60 60) (72 72) (60 72) (60 67) (67 60) (67 67) (67 72) (72 67) (60 64) (64 60) (64 67) (67 64) (64 64) (64 72) (72 64) (62 62) (62 66) (66 62) (66 66) (62 69) (69 69) (69 62) (66 69) (69 66)))))$        ;(consonantRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((60 72) (72 60) (60 60) (72 72) (60 72) (60 67) (67 60) (67 67) (67 72) (72 67) (60 64) (64 60) (64 67) (67 64) (64 64) (64 72) (72 64)))))$        ;(consonantRel (first (createBoundedFullGroundRelation gm '((60 72) (60 72)))))$        ;USED FOR THE PAPER FOR NOW(consonantRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((60 72) (72 60) (60 60) (72 72) (60 72) (60 67) (67 60) (67 67) (67 72) (72 67)))))$        ;(consonantRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((61 61) (62 62) (63 63) (64 64) (65 65) (66 66) (68 68) (69 69) (70 70) (71 71) (60 72) (72 60) (60 60) (72 72) (60 72) (60 67) (67 60) (67 67) (67 72) (72 67)))))$        (consonantRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '( (61 61) (60 72) (72 60) (60 60) (72 72) (60 72) (60 67) (67 60) (67 67) (67 72) (72 67)))))$        ;(consonantRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((60 72) (72 60) (60 60) (72 72) (60 72) (60 67) (67 60) (67 67) (67 72) (72 67) (62 62) (62 69) (69 62) (69 69)))))$$        ;ground relations for additonal constraints$        (lubScorePart1 (first (createBoundedFullGroundRelation gm '((60 72) (1 8)))))$        (lubScorePart2 (first (createBoundedFullGroundRelation gm '((60 72) (9 16)))))$        ;(onsetsPart1Rel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((1) (2) (3) (4) (5) (6) (7) (8)))))$        (onsetsPart1Rel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((1) (2) (3) (4)))))$        ;(onsetsPart2Rel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((9) (10) (11) (12) (13) (14) (15) (16)))))$        (onsetsPart2Rel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm '((9) (10) (11) (12)))))$        (lubOffPart (first (createBoundedFullGroundRelation gm '((8 8)))))$        (lubPart1Off (first (createBoundedFullGroundRelation gm '((60 72) (1 8) (8 8)))))$$        ;variable declarations$        (plusVar nil)$        (scoreVar nil)$        (permutScoreVar nil)$        (scoreOffVar nil)$        ;(scoreOffPlusVar nil)$        (offVar nil)$        (V0Var nil)$        (V1Var nil)$        (ppVar nil)$        (consonantVar nil)$$        ;variable for additional constraints$        (V0part1 nil)$        (V0part2 nil)$        (onsetsPart1 nil)$        (onsetsPart2 nil)$        (joinPart1Var nil)$        (offPart1Var nil)$        (part1V0ShiftVar nil)$        $$        ;search declarations$        (se nil)$        (sol1 nil)$        (solScoreRel nil)$        (solV0Rel nil)$        (solV1Rel nil)$        )$$        ;variables creation$        (setq plusVar (newCPRelVar gm sp plusRel plusRel))$        (setq scoreVar (newCPRelVar gm sp glbScore lubScore))$        (setq permutScoreVar (newCPRelVar gm sp glbScore lubPermutScore))$        (setq offVar (newCPRelVar gm sp lubOff lubOff))$        (setq scoreOffVar (newCPRelVar gm sp glbScoreOff lubScoreOff))$        (setq V0Var (newCPRelVar gm sp glbV0 lubScore))$        (setq V1Var (newCPRelVar gm sp glbScore lubScore))$        (setq ppVar (newCPRelVar gm sp glbScore lubPP))$        (setq consonantVar (newCPRelVar gm sp consonantRel consonantRel))$$        ;variables for additional constraints$        (setq V0part1 (newCPRelVar gm sp glbScore lubScorePart1))$        (setq V0part2 (newCPRelVar gm sp glbScore lubScorePart2))$        (setq onsetsPart1 (newCPRelVar gm sp onsetsPart1Rel onsetsPart1Rel))$        (setq onsetsPart2 (newCPRelVar gm sp onsetsPart2Rel onsetsPart2Rel))$        (setq joinPart1Var (newCPRelVar gm sp glbScoreOff lubPart1Off))$        (setq offPart1Var (newCPRelVar gm sp lubOffPart lubOffPart))$        (setq part1V0ShiftVar (newCPRelVar gm sp glbScore lubScorePart2))$        $$        ;constraints$        (joinConstraint gm sp V0Var 0 offVar scoreOffVar)$        (followConstraint gm sp scoreOffVar 2 plusVar V1Var)$        (unionConstraint gm sp V0Var V1Var scoreVar)$        $        (permutationConstraint gm sp scoreVar permutScoreVar permDesc)$$        (followConstraint gm sp scoreVar 1 permutScoreVar ppVar)$$        (subsetConstraint gm sp ppVar consonantVar)$$        ;extra constraint to have disjoint voices$$        (disjointConstraint gm sp V0Var V1Var)$$$        ;additional constraints$$        (joinConstraint gm sp V0Var 1 onsetsPart1 V0part1)$        (joinConstraint gm sp V0Var 1 onsetsPart2 V0part2)$        (joinConstraint gm sp V0part1 0 offPart1Var joinPart1Var)$        (followConstraint gm sp joinPart1Var 2 plusVar part1V0ShiftVar)$        (disjointConstraint gm sp part1V0ShiftVar V0part2)$$        ;branching$        (branch gm sp scoreVar)$        (branch gm sp V0Var)$        (branch gm sp V1Var)$$        ;search$        ;search engine dfs$        (setq se (newSearchEngine gm sp 0))$$        ;(printSpace gm sp)$        $        ;get a solution$        (setq sol1 (nextSolution gm sp se))$$        (print \"Found the solution (if 0 no solution) : \")$$        ;(print sol1)$$        (if (string/= sol1 \"0\");if there is a solution$        ;then$        ;get a var from the solution space$            (progn$              (setq solScoreRel (getVarInSpace gm sol1 scoreVar))$              (setq solV0Rel (getVarInSpace gm sol1 V0Var))$              (setq solV1Rel (getVarInSpace gm sol1 V1Var))$              (print \"The part 1 :\")$              (setq solV0Part1Rel (getVarInSpace gm sol1 V0part1))$              (setq testOff (getVarInSpace gm sol1 offPart1Var))$              (setq testJoined (getVarInSpace gm sol1 joinPart1Var))$              (print solV0Part1Rel)$              (print testOff)$              (print testJoined)$             )$        ;else$          (progn$              (setq solScoreRel nil)$              (setq solV0Rel nil)$              (setq solV1Rel nil)$             )$          $         )$$        $$        (setq toReturn (list solV0Rel solV1Rel solScoreRel))$$$)$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil))) (om-make-point 244 217) nil nil "&" "intro"))) (quote ((9 0 3 0 nil 0) (8 0 3 1 nil 0) (5 0 8 0 nil 0) (4 0 8 1 nil 0) (7 0 9 0 nil 0) (6 0 9 1 nil 0) (17 0 10 0 nil 0) (19 0 10 1 nil 0) (10 0 11 1 nil 0) (11 0 12 0 nil 0) (20 0 12 1 nil 0) (3 0 12 2 nil 0) (25 0 13 0 nil 0) (25 0 14 0 nil 0) (25 0 15 0 nil 0) (15 0 16 0 nil 0) (2 0 16 1 nil 0) (16 0 17 0 nil 0) (14 0 18 0 nil 0) (1 0 18 1 nil 0) (18 0 19 0 nil 0) (21 0 20 0 nil 0) (13 0 21 0 nil 0) (23 0 22 0 nil 0) (12 0 22 1 nil 0) (23 0 24 0 nil 0) (23 0 25 0 nil 0) (24 0 25 1 nil 0))) nil 6.050003))
