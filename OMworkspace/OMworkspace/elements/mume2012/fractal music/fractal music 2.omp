; OM File Header - Saved 2012/06/18 17:22:45
; (6.050003 :patc (om-make-point 10 10) (om-make-point 0 22) (om-make-point 1280 752) "" 183 0 "2012/06/13 23:42:26" "2012/06/18 17:22:45")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "fractal music 2" (quote ((om-load-boxcall (quote bastype) "string 4" (quote string) (quote nil) (om-make-point 384 478) (om-make-point 840 30) "We could try to enforce this constraint only on subparts of the score, using the join constraint to get them (e.g. some given onset, or duration)" "\"We could try to enforce this constraint only on subparts of the score, using the join constraint to get them (e.g. some given onset, or duration)\"" nil) (om-load-boxcall (quote bastype) "string 3" (quote string) (quote nil) (om-make-point 403 340) (om-make-point 838 43) "The constraint actually allows to enforce that for all accessible things from the Score relation and using the Transform relation, 
if at least one of those accessible things are used at some point (e.g. a given onset), all of them will be used. If not, none of them will be used." "\"The constraint actually allows to enforce that for all accessible things from the Score relation and using the Transform relation, $if at least one of those accessible things are used at some point (e.g. a given onset), all of them will be used. If not, none of them will be used.\"" nil) (om-load-boxcall (quote bastype) "string 2" (quote string) (quote nil) (om-make-point 551 415) (om-make-point 499 30) "Inevitably, this constraint is then global for the whole structure (the whole relation)" "\"Inevitably, this constraint is then global for the whole structure (the whole relation)\"" nil) (om-load-boxcall (quote bastype) "string" (quote string) (quote nil) (om-make-point 238 270) (om-make-point 892 30) "The fractal constraint (Score = Score follow transform) only works if forall x : t++x in Score : exists y : t++y in Score wedge x++y in Transfrom" "\"The fractal constraint (Score = Score \\follow transform) only works if \\forall x : t++x \\in Score : \\exists y : t++y \\in Score \\wedge x++y \\in Transfrom\"" nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 418 602) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6000) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400))) :lonset (quote (500 1000 1500 2000 3000 3500 4000 4500 5000 6000 6500 7000 7500 8000 500 1000 1500 2000 3000 3500 4000 4500 5000 6000 6500 7000 7500 8000 8500)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 0 -778) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 593 303) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote abstraction) "rel as score" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 0 -778) (om-make-point 1280 752)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 449 393) nil nil "&" "rel as score") (om-load-boxcall (quote abstraction) "fractal" (om-load-lisp-abspatch "fractal" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp) $$  (let$$      ($       (glbScore (newGRelation gm 2))$       (pitches (first (createBoundedFullGroundRelation gm '((60 72)))))$       (onsets (first (createBoundedFullGroundRelation gm '((1 16)))))$       ;(duration (first (createBoundedFullGroundRelation gm '((1 4)))))$       $       (glbTransform (newGRelation gm 2))$       $       (lubScore nil)$       (scoreVar nil)$       $       (TransformVar nil)$$       (se nil)$$       (solScoreRel nil)$      )$$    ;the score$    ;(setq lubScore (GRelation-Times gm (GRelation-Times gm duration onsets) pitches))$    (setq lubScore (GRelation-Times gm onsets pitches))$    (setq scoreVar (newCPRelVar gm sp glbScore lubScore))$    $    ;the transformation$    ;(GRelation-AddTuple gm glbTransform (newTuple gm '(60 60)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(60 64)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(64 60)))$    ;(GRelation-AddTuple gm glbTransform (newTuple gm '(64 67)))$    #|(GRelation-AddTuple gm glbTransform (newTuple gm '(61 61))) $    (GRelation-AddTuple gm glbTransform (newTuple gm '(62 62)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(63 63)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(64 64)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(65 65)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(66 66)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(67 67)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(68 68)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(69 69)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(70 70)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(71 71)))$    (GRelation-AddTuple gm glbTransform (newTuple gm '(72 72)))|#$$    (setq TransformVar (newCPRelVar gm sp glbTransform glbTransform))$$    ;constraints$    (followConstraint gm sp scoreVar 1 TransformVar scoreVar)$$    ;branching $    (branch gm sp scoreVar)$$    ;print$    (printSpace gm sp)$    $    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$    (setq sol1 (nextSolution gm sp se))$    (setq sol1 (nextSolution gm sp se))$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel (getVarInSpace gm sol1 scoreVar))$     )$     ;else$     ()$    )$     $$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil))) (om-make-point 460 198) nil nil nil "fractal") (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 179 983) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 444 59) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 87 40) nil nil "&" "create Gecode manager"))) (quote ((6 0 4 0 nil 0) (7 0 6 0 nil 0) (5 0 6 1 nil 0) (10 0 7 0 nil 0) (9 0 7 1 nil 0) (10 0 8 0 nil 0) (4 0 8 1 nil 0) (10 0 9 0 nil 0))) nil 6.050003))
