; OM File Header - Saved 2012/09/04 14:48:54
; (6.050003 :patc (om-make-point 118 10) (om-make-point 0 0) (om-make-point 1280 774) "" 183 0 "2012/06/18 11:26:59" "2012/08/16 17:49:20")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "lindenmayer comparison with strasheela" (quote ((om-load-boxcall (quote abstraction) "rel as score 2" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 532 116) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 400 "400" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 573 310) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (9 0 2 0 nil 0) (10 0 4 0 nil 0) (3 0 4 1 nil 0) (12 0 6 1 nil 0) (0 0 6 2 nil 0) (4 0 6 3 nil 0) (5 0 6 6 nil 0) (6 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (9 0 11 0 nil 0) (11 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 683 598) nil nil "&" "rel as score") (om-load-boxcall (quote abstraction) "rel as score" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 532 116) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 400 "400" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 573 310) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (9 0 2 0 nil 0) (10 0 4 0 nil 0) (3 0 4 1 nil 0) (12 0 6 1 nil 0) (0 0 6 2 nil 0) (4 0 6 3 nil 0) (5 0 6 6 nil 0) (6 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (9 0 11 0 nil 0) (11 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 516 598) nil nil "&" "rel as score") (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 298 713) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((4800) (5000) (5200) (5300))) :lonset (quote (500 1000 1500 2000 2500)) :ldur (quote ((400) (400) (400) (400))) :lvel (quote ((100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 14/25 nil 1000 0 (om-make-point 1280 752) (om-make-point 278 1200) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote bastype) "list 15" (quote list) (quote nil) (om-make-point 435 504) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote abstraction) "rel as score 3" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 532 116) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 400 "400" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 573 310) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (9 0 2 0 nil 0) (10 0 4 0 nil 0) (3 0 4 1 nil 0) (12 0 6 1 nil 0) (0 0 6 2 nil 0) (4 0 6 3 nil 0) (5 0 6 6 nil 0) (6 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (9 0 11 0 nil 0) (11 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 0 0) (om-make-point 1920 1156)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 319 594) nil nil "&" "rel as score") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 332 449) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 447 716) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((4800) (5000) (5200) (4800) (5300) (5900) (4800) (4800) (5900) (5900) (6400) (6700) (6400) (6700) (6400) (6700))) :lonset (quote (500 1000 1500 2500 2000 2500 4000 5500 4000 5500 2500 2500 4000 4000 5500 5500 5500)) :ldur (quote ((400) (400) (400) (1200) (400) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 359 72) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote bastype) "list 14" (quote list) (quote nil) (om-make-point 625 507) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 519 451) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "LIST 13" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 387 836) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 661 714) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((4800) (5000) (5200) (4800) (5300) (5500) (5200) (5900) (4800) (4800) (4800) (5900) (5900) (6400) (6700) (6400) (6700) (6400) (6700))) :lonset (quote (500 1000 1500 2500 2000 2500 3500 2500 4000 4500 5500 4000 5500 2500 2500 4000 4000 5500 5500 5500)) :ldur (quote ((400) (400) (400) (1200) (400) (800) (800) (1200) (1200) (800) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 0 1024) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote bastype) "list 12" (quote list) (quote nil) (om-make-point 845 515) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 697 472) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 11" (quote list) (quote nil) (om-make-point 971 27) (om-make-point 21 30) 4 "4" nil) (om-load-boxcall (quote bastype) "list 10" (quote list) (quote nil) (om-make-point 904 21) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "LIST 9" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 1) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 919 65) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "LIST 8" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 828 63) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 756 13) (om-make-point 28 30) 72 "72" nil) (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 668 21) (om-make-point 28 30) 48 "48" nil) (om-load-boxcall (quote lispfun) "LIST 5" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 48) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 72))) (om-make-point 746 58) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "possible pitch, onset and duration" (om-load-lisp-abspatch "possible pitch, onset and duration" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"possible pitch, onset and duration\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm pitchMinMax onsetMinMax durationMinMax)$$  (let ($        (pitches (first (createBoundedFullGroundRelation gm (list pitchMinMax))))$        (onsets (first (createBoundedFullGroundRelation gm (list onsetMinMax))))$        (duration (first (createBoundedFullGroundRelation gm (list durationMinMax))))$        (toReturn nil)$        )$$    (setq toReturn (list pitches onsets duration))$$    )$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "PITCHMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "ONSETMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "DURATIONMINMAX" nil))) (om-make-point 752 137) nil nil "&" "possible pitch, onset and duration") (om-load-boxcall (quote abstraction) "problem definition" (om-load-lisp-abspatch "problem definition" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"problem definition\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp plusRel patternsAndPatternIds rules pitchOnsetDuration) $$$  (let$      ($       ;glbs and lubs$       ;glbs$       (glbScore (newGRelation gm 3))$       (glbOfPat (newGRelation gm 2))$       (glbOfScore (newGRelation gm 4))$       (glbPermutOfScore (newGRelation gm 4))$       ;lubs$       (lubScore nil)$       (lubOfPat nil)$       (lubOfScore nil)$       (lubPermutOfScore nil)$$       ;pitch, onset and duration ground relations$       (pitches (first pitchOnsetDuration))$       (onsets (second pitchOnsetDuration))$       (durations (third pitchOnsetDuration))$       $$       ;plusRel$       (plusVar (newCPRelVar gm sp plusRel plusRel))$$       ;patterns$       (patternsVar (newCPRelVar gm sp (first patternsAndPatternIds) (first patternsAndPatternIds)))$       (patternIds (second patternsAndPatternIds))$$       ;rules$       (rulesOP (newCPRelVar gm sp (first rules) (first rules)))$       (rulesP (newCPRelVar gm sp (second rules) (second rules)))$$       $       ;axiom$       (glbAxiom (newGRelation gm 2))$       (axiomVar nil) ; OffsetOnset | Pattern$$       ;scores as relations between patterns and offsets in time (onset)     $       (ofPat0 nil)$       (ofPat1 nil)$       (ofPat2 nil)$$       ;intermediate transformations of ofPat relations$       ;binary transformations$       (ofPat0TOP nil)$       (ofPat1TOP nil)$       $       ;unary transformations$       (ofPat0TP nil)$       (ofPat1TP nil)$$       ;ofScore$       (ofScore0 nil)$       (ofScore1 nil)$       (ofScore2 nil)$$       ;permuted ofScore$       (permOfScore0 nil)$       (permOfScore1 nil)$       (permOfScore2 nil)$$      $       ;var$       (scoreVar0 nil)$       (scoreVar1 nil)$       (scoreVar2 nil)$$       ;different solution steps$       (solScoreRel0 nil)$       (solScoreRel1 nil)$       (solScoreRel2 nil)$$      ;search engine$      (se nil)$$      ;solution$      (sol1 nil)$$     )$    $    (print \"After the let !\")$$    ;axiom$    (GRelation-AddTuple gm glbAxiom (newTuple gm '(0 1))) ; first pattern is played on onset 1$    (setq axiomVar (newCPRelVar gm sp glbAxiom glbAxiom))$    $    ;scores as relations between patterns and offsets in time (onset)$    (setq lubOfPat (GRelation-Times gm onsets patternIds))$    (setq ofPat0 (newCPRelVar gm sp glbOfPat lubOfPat))$    (setq ofPat1 (newCPRelVar gm sp glbOfPat lubOfPat))$    (setq ofPat2 (newCPRelVar gm sp glbOfPat lubOfPat))$$$    ; Relation Offset | Score (Pitch, Duration, Onset)$    (setq lubOfScore (GRelation-Times gm (GRelation-Times gm onsets pitches) (GRelation-Times gm durations onsets)))$    (setq ofScore0 (newCPRelVar gm sp glbOfScore lubOfScore))$    (setq ofScore1 (newCPRelVar gm sp glbOfScore lubOfScore))$    (setq ofScore2 (newCPRelVar gm sp glbOfScore lubOfScore))$$    $    ;permuted Relation Offset | Score (Pitch, Duration, Onset)$    (setq lubPermutOfScore (GRelation-Times gm (GRelation-Times gm durations pitches) (GRelation-Times gm onsets onsets)))$    (setq permOfScore0 (newCPRelVar gm sp glbPermutOfScore lubPermutOfScore))$    (setq permOfScore1 (newCPRelVar gm sp glbPermutOfScore lubPermutOfScore))$    (setq permOfScore2 (newCPRelVar gm sp glbPermutOfScore lubPermutOfScore))$$$    ;scores$    (setq lubScore (GRelation-Times gm durations (GRelation-Times gm pitches onsets )))$    (setq scoreVar0 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar1 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar2 (newCPRelVar gm sp glbScore lubScore))$    $    (print \"before constraints !\")$$$    ;constraints$$    ;axiom is the first score$    (equalConstraint gm sp axiomVar ofPat0)$$    ;generation of the score from the relations ofPat$   $    ;link subscore with corresponding offset $    (followConstraint gm sp ofPat0 1 patternsVar ofScore0)$    (followConstraint gm sp ofPat1 1 patternsVar ofScore1)$    (followConstraint gm sp ofPat2 1 patternsVar ofScore2)$    ;permute those link$    (permutationConstraint gm sp ofScore0 permOfScore0 '((1 3))) ; duration | pitch | onset | offset$    (permutationConstraint gm sp ofScore1 permOfScore1 '((1 3)))$    (permutationConstraint gm sp ofScore2 permOfScore2 '((1 3)))$$$    ;reconstruct the scores by adding the offset to the onset parameter$    (followConstraint gm sp permOfScore0 2 plusVar scoreVar0)$    (followConstraint gm sp permOfScore1 2 plusVar scoreVar1)$    (followConstraint gm sp permOfScore2 2 plusVar scoreVar2)$   $$   $$$$    ;lindenmayer part$    ;first step$    ;auxiliary variables$    (setq ofPat0TOP (newCPRelVar gm sp glbOfPat lubOfPat))$    (setq ofPat0TP (newCPRelVar gm sp glbOfPat lubOfPat))$    ;constraints$    (followConstraint gm sp ofPat0 2 rulesOP ofPat0TOP)$    (followConstraint gm sp ofPat0 1 rulesP ofPat0TP)$    (unionConstraint gm sp ofPat0TOP ofPat0TP ofPat1) $$    ;second step$    ;auxiliary variables$    (setq ofPat1TOP (newCPRelVar gm sp glbOfPat lubOfPat))$    (setq ofPat1TP (newCPRelVar gm sp glbOfPat lubOfPat))$    ;constraints$    (followConstraint gm sp ofPat1 2 rulesOP ofPat1TOP)$    (followConstraint gm sp ofPat1 1 rulesP ofPat1TP)$    (unionConstraint gm sp ofPat1TOP ofPat1TP ofPat2) $$$$    ;branching $    (branch gm sp scoreVar0)$    (branch gm sp scoreVar1)$    (branch gm sp scoreVar2)$$    (print \"before print\")$    ;print$    ;(printSpace gm sp)$    $    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel0 (getVarInSpace gm sol1 scoreVar0))$          (setq solScoreRel1 (getVarInSpace gm sol1 scoreVar1))$          (setq solScoreRel2 (getVarInSpace gm sol1 scoreVar2))$  $     )$     ;else$     ()$    )$$    (printSpace gm sol1)$$    (print (list solScoreRel0 solScoreRel1 solScoreRel2))$)$$$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil) (om-load-inputfun (quote input-funbox) "" "PLUSREL" nil) (om-load-inputfun (quote input-funbox) "" "PATTERNSANDPATTERNIDS" nil) (om-load-inputfun (quote input-funbox) "" "RULES" nil) (om-load-inputfun (quote input-funbox) "" "PITCHONSETDURATION" nil))) (om-make-point 410 352) nil nil "&" "problem definition") (om-load-boxcall (quote abstraction) "create rules" (om-load-lisp-abspatch "create rules" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $  $  (let $      ($       (ruleOP (newGRelation gm 4));  offset1 | pattern1 | offet2 | pattern2 $       (ruleP (newGRelation gm 2)) ; pattern1 | pattern2$       (ruleList nil)$       )$$$    ;Rules on offset pattern combined$    (GRelation-AddTuple gm ruleOP (newTuple gm '(0 1 4 2)))$    $    ;Rules on pattern$    (GRelation-AddTuple gm ruleP (newTuple gm '(2 3)))$    (GRelation-AddTuple gm ruleP (newTuple gm '(1 1)))$    (GRelation-AddTuple gm ruleP (newTuple gm '(2 2)))$    (GRelation-AddTuple gm ruleP (newTuple gm '(3 3)))$$    ;return$    (setq ruleList (list ruleOP ruleP))$$)$  $$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 654 135) nil nil "&" "create rules") (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 504 30) (om-make-point 28 30) 20 "20" nil) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 455 29) (om-make-point 21 30) 0 "0" nil) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 414 30) (om-make-point 28 30) 20 "20" nil) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 367 31) (om-make-point 21 30) 0 "0" nil) (om-load-boxcall (quote abstraction) "create patterns" (om-load-lisp-abspatch "create patterns" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create patterns\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$$$; The patterns come from the example provided by Torsten Anders. Here they are fixed.$(lambda (gm)$$  (let $      ($       (patterns (newGRelation gm 4)); Pattern | Pitch | Duration | Onset$       (patternsAndPatternIds nil)$       )$$$    ;Pattern1 (run)$    (GRelation-AddTuple gm patterns (newTuple gm '(1 48 1 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(1 50 1 2)))$    (GRelation-AddTuple gm patterns (newTuple gm '(1 52 1 3)))$    (GRelation-AddTuple gm patterns (newTuple gm '(1 53 1 4)))$$    ;Pattern2 (chord repetition)$    (GRelation-AddTuple gm patterns (newTuple gm '(2 48 3 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 59 3 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 64 3 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 67 3 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 48 3 4)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 59 3 4)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 64 3 4)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 67 3 4)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 48 3 7)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 59 3 7)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 64 3 7)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 67 3 7)))$$    ;Pattern3 (arpeggio)$    (GRelation-AddTuple gm patterns (newTuple gm '(3 55 2 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(3 52 2 3)))$    (GRelation-AddTuple gm patterns (newTuple gm '(3 48 2 5)))$    $    ;return$    (setq patternsAndPatternIds (list patterns (first (createBoundedFullGroundRelation gm '((1 3))))))$    )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 523 136) nil nil "&" "create patterns") (om-load-boxcall (quote abstraction) "create plus" (om-load-lisp-abspatch "create plus" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create plus\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm minX maxX minY maxY)$$  (let ($          (plusRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm (createBoundedPlus (list minX maxX) (list minY maxY)))))$        )$$    (setq plusRel plusRel)$$  )$$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "MINX" 0) (om-load-inputfun (quote input-funbox) "" "MAXX" nil) (om-load-inputfun (quote input-funbox) "" "MINY" nil) (om-load-inputfun (quote input-funbox) "" "MAXY" nil))) (om-make-point 413 139) nil nil "&" "create plus") (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 256 930) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 290 140) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 128 42) nil nil "&" "create Gecode manager"))) (quote ((12 0 0 0 nil 0) (11 0 0 1 nil 0) (8 0 1 0 nil 0) (7 0 1 1 nil 0) (4 0 2 0 nil 0) (5 0 4 0 nil 0) (3 0 4 1 nil 0) (21 0 5 0 nil 0) (1 0 6 0 nil 0) (21 0 8 0 nil 0) (2 0 9 0 nil 0) (6 0 9 1 nil 0) (10 0 9 2 nil 0) (0 0 10 0 nil 0) (21 0 12 0 nil 0) (14 0 15 0 nil 0) (13 0 15 1 nil 0) (26 0 16 0 nil 0) (25 0 16 1 nil 0) (18 0 19 0 nil 0) (17 0 19 1 nil 0) (31 0 20 0 nil 0) (19 0 20 1 nil 0) (16 0 20 2 nil 0) (15 0 20 3 nil 0) (31 0 21 0 nil 0) (30 0 21 1 nil 0) (28 0 21 2 nil 0) (27 0 21 3 nil 0) (22 0 21 4 nil 0) (20 0 21 5 nil 0) (31 0 22 0 nil 0) (31 0 27 0 nil 0) (31 0 28 0 nil 0) (26 0 28 1 nil 0) (25 0 28 2 nil 0) (24 0 28 3 nil 0) (23 0 28 4 nil 0) (31 0 29 0 nil 0) (9 0 29 1 nil 0) (31 0 30 0 nil 0))) nil 6.050003))
