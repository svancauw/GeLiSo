; OM File Header - Saved 2012/06/26 18:46:09
; (6.050003 :patc (om-make-point 118 10) (om-make-point 0 0) (om-make-point 1280 752) "" 183 0 "2012/06/18 11:26:59" "2012/06/26 18:46:09")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "lindenmayer comparison with strasheela" (quote ((om-load-boxcall (quote abstraction) "rel as score 2" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 532 116) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 400 "400" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 573 310) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (9 0 2 0 nil 0) (10 0 4 0 nil 0) (3 0 4 1 nil 0) (12 0 6 1 nil 0) (0 0 6 2 nil 0) (4 0 6 3 nil 0) (5 0 6 6 nil 0) (6 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (9 0 11 0 nil 0) (11 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 683 598) nil nil "&" "rel as score") (om-load-boxcall (quote abstraction) "rel as score" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 532 116) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 400 "400" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 573 310) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (9 0 2 0 nil 0) (10 0 4 0 nil 0) (3 0 4 1 nil 0) (12 0 6 1 nil 0) (0 0 6 2 nil 0) (4 0 6 3 nil 0) (5 0 6 6 nil 0) (6 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (9 0 11 0 nil 0) (11 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 516 598) nil nil "&" "rel as score") (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 298 713) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((4800) (5000) (5200) (5300))) :lonset (quote (1000 1500 2000 2500 3000)) :ldur (quote ((400) (400) (400) (400))) :lvel (quote ((100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 278 1200) (om-make-point 1280 752) 0 1000 nil 14/25 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote bastype) "list 15" (quote list) (quote nil) (om-make-point 435 504) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote abstraction) "rel as score 3" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 532 116) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 400 "400" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 573 310) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (9 0 2 0 nil 0) (10 0 4 0 nil 0) (3 0 4 1 nil 0) (12 0 6 1 nil 0) (0 0 6 2 nil 0) (4 0 6 3 nil 0) (5 0 6 6 nil 0) (6 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (9 0 11 0 nil 0) (11 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 0 0) (om-make-point 1920 1156)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 319 594) nil nil "&" "rel as score") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 332 449) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 447 716) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((4800) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (5500) (5200) (5200) (5500) (5500) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (4800) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5200) (5200) (5200) (5500) (5500) (5500) (5500) (5900) (5900) (5900) (5900) (5900) (5900) (5900) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (5000) (5000) (5000) (5000) (5000) (5000) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5200) (5200) (5200) (5200) (5200) (5200) (5200) (5500) (5500) (5500) (5500) (5500) (5500) (5500) (5500) (5900) (5900) (5900) (5900) (5900) (5900) (5900) (5900) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (5000) (5000) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5200) (5200) (5200) (5500) (5500) (5500) (5500) (4800) (4800) (4800) (5000) (5200) (5300) (5200) (5500) (5900) (5900) (5900) (5900) (5900) (6400) (6700) (6400) (6400) (6700) (6700) (6400) (6400) (6400) (6400) (6700) (6700) (6700) (6700) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6700) (6700) (6700) (6700) (6700) (6700) (6700) (6700) (6400) (6400) (6400) (6400) (6700) (6700) (6700) (6700) (6400) (6700))) :lonset (quote (500 500 1000 1000 1500 1500 1000 1500 500 1500 1500 1000 1500 2000 2500 2000 2500 2500 2000 2500 3000 3500 3000 3000 3500 3500 3000 3500 2000 2000 2500 2500 3000 3000 3500 3500 2000 2500 3000 3500 2000 2500 3000 3500 500 1000 1500 2000 2500 3000 3500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4000 4500 4500 5000 5000 5500 5500 6000 6000 6500 6500 7000 7000 7500 7500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4000 4500 4500 5000 5000 5500 5500 6000 6000 6500 6500 7000 7000 7500 7500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4500 5000 5500 6000 6500 7000 7500 8000 8500 9000 9500 8000 8000 8500 8500 9000 9000 9500 9500 8000 8500 9000 9500 8000 8000 8500 8500 9000 9000 9500 9500 8000 8500 9000 9500 8000 8500 9000 9500 10000 10000 10000 10000 10000 10000 10000 10000 8000 8500 9000 9500 10000 500 500 1000 1500 1000 1500 2000 2500 3000 3500 2000 2500 3000 3500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4500 5000 5500 6000 6500 7000 7500 8000 8500 9000 9500 8000 8500 9000 9500 10000 10000 10000)) :ldur (quote ((1200) (400) (1200) (400) (1200) (400) (400) (400) (800) (400) (800) (800) (800) (400) (400) (1200) (800) (1200) (400) (400) (400) (400) (800) (1200) (800) (1200) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (800) (800) (800) (800) (800) (800) (800) (800) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (400) (400) (400) (400) (400) (400) (400) (400) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (400) (400) (400) (400) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (800) (800) (800) (800) (800) (800) (800) (800) (400) (800) (1200) (400) (400) (400) (800) (800) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 22) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote bastype) "list 14" (quote list) (quote nil) (om-make-point 625 507) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 519 451) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "LIST 13" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 387 836) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 661 714) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((4800) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (5500) (5200) (5200) (5500) (5500) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (4800) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5200) (5200) (5200) (5500) (5500) (5500) (5500) (5900) (5900) (5900) (5900) (5900) (5900) (5900) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (5000) (5000) (5000) (5000) (5000) (5000) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5200) (5200) (5200) (5200) (5200) (5200) (5200) (5500) (5500) (5500) (5500) (5500) (5500) (5500) (5500) (5900) (5900) (5900) (5900) (5900) (5900) (5900) (5900) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (4800) (5000) (5000) (5000) (5000) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5300) (5200) (5200) (5200) (5200) (5500) (5500) (5500) (5500) (4800) (4800) (4800) (5000) (5200) (5300) (5200) (5500) (5900) (5900) (5900) (5900) (5900) (6400) (6700) (6400) (6400) (6700) (6700) (6400) (6400) (6400) (6400) (6700) (6700) (6700) (6700) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6400) (6700) (6700) (6700) (6700) (6700) (6700) (6700) (6700) (6400) (6400) (6400) (6400) (6700) (6700) (6700) (6700) (6400) (6700))) :lonset (quote (500 500 1000 1000 1500 1500 1000 1500 500 1500 1500 1000 1500 2000 2500 2000 2500 2500 2000 2500 3000 3500 3000 3000 3500 3500 3000 3500 2000 2000 2500 2500 3000 3000 3500 3500 2000 2500 3000 3500 2000 2500 3000 3500 500 1000 1500 2000 2500 3000 3500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4000 4500 4500 5000 5000 5500 5500 6000 6000 6500 6500 7000 7000 7500 7500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4000 4500 4500 5000 5000 5500 5500 6000 6000 6500 6500 7000 7000 7500 7500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4500 5000 5500 6000 6500 7000 7500 8000 8500 9000 9500 8000 8000 8500 8500 9000 9000 9500 9500 8000 8500 9000 9500 8000 8000 8500 8500 9000 9000 9500 9500 8000 8500 9000 9500 8000 8500 9000 9500 10000 10000 10000 10000 10000 10000 10000 10000 8000 8500 9000 9500 10000 500 500 1000 1500 1000 1500 2000 2500 3000 3500 2000 2500 3000 3500 4000 4500 5000 5500 6000 6500 7000 7500 4000 4500 5000 5500 6000 6500 7000 7500 8000 8500 9000 9500 8000 8500 9000 9500 10000 10000 10000)) :ldur (quote ((1200) (400) (1200) (400) (1200) (400) (400) (400) (800) (400) (800) (800) (800) (400) (400) (1200) (800) (1200) (400) (400) (400) (400) (800) (1200) (800) (1200) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (800) (800) (800) (800) (800) (800) (800) (800) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (400) (400) (400) (400) (400) (400) (400) (400) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (800) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (400) (400) (400) (400) (800) (1200) (800) (1200) (800) (1200) (800) (1200) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (400) (800) (800) (800) (800) (800) (800) (800) (800) (400) (800) (1200) (400) (400) (400) (800) (800) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200) (1200))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 278 1200) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote bastype) "list 12" (quote list) (quote nil) (om-make-point 845 515) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 697 472) nil nil nil nil 1) (om-load-boxcall (quote bastype) "string 5" (quote string) (quote nil) (om-make-point 1024 681) (om-make-point 494 30) "The rules can be very general : a pitch could be used to get a pattern for instance" "\"The rules can be very general : a pitch could be used to get a pattern for instance\"" nil) (om-load-boxcall (quote bastype) "list 11" (quote list) (quote nil) (om-make-point 971 27) (om-make-point 21 30) 4 "4" nil) (om-load-boxcall (quote bastype) "list 10" (quote list) (quote nil) (om-make-point 904 21) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "LIST 9" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 1) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 919 65) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "LIST 8" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 828 63) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 756 13) (om-make-point 28 30) 72 "72" nil) (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 668 21) (om-make-point 28 30) 48 "48" nil) (om-load-boxcall (quote lispfun) "LIST 5" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 48) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 72))) (om-make-point 746 58) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "possible pitch, onset and duration" (om-load-lisp-abspatch "possible pitch, onset and duration" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"possible pitch, onset and duration\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm pitchMinMax onsetMinMax durationMinMax)$$  (let ($        (pitches (first (createBoundedFullGroundRelation gm (list pitchMinMax))))$        (onsets (first (createBoundedFullGroundRelation gm (list onsetMinMax))))$        (duration (first (createBoundedFullGroundRelation gm (list durationMinMax))))$        (toReturn nil)$        )$$    (print \"we go until here ?\")$    (setq toReturn (list pitches onsets duration))$$    )$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "PITCHMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "ONSETMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "DURATIONMINMAX" nil))) (om-make-point 752 137) nil nil "&" "possible pitch, onset and duration") (om-load-boxcall (quote abstraction) "problem definition" (om-load-lisp-abspatch "problem definition" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"problem definition\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp plusRel patternsAndPatternIds rules pitchOnsetDuration) $$$  (let$      ($       ;glbs and lubs$       ;glbs$       (glbScore (newGRelation gm 3))$       (glbOfPat (newGRelation gm 2))$       (glbOfScore (newGRelation gm 4))$       (glbPermutOfScore (newGRelation gm 4))$       ;lubs$       (lubScore nil)$       (lubOfPat nil)$       (lubOfScore nil)$       (lubPermutOfScore nil)$$       ;pitch, onset and duration ground relations$       (pitches (first pitchOnsetDuration))$       (onsets (second pitchOnsetDuration))$       (durations (third pitchOnsetDuration))$       $$       ;plusRel$       (plusVar (newCPRelVar gm sp plusRel plusRel))$$       ;patterns$       (patternsVar (newCPRelVar gm sp (first patternsAndPatternIds) (first patternsAndPatternIds)))$       (patternIds (second patternsAndPatternIds))$$       ;rules$       (rulesPO (newCPRelVar gm sp (first rules) (first rules)))$       (rulesP (newCPRelVar gm sp (second rules) (second rules)))$$       $       ;axiom$       (glbAxiom (newGRelation gm 2))$       (axiomVar nil) ; OffsetOnset | Pattern$$       ;scores as relations between patterns and offsets in time (onset)     $       (ofPat0 nil)$       (ofPat1 nil)$       (ofPat2 nil)$$$       ;ofScore$       (ofScore0 nil)$       (ofScore1 nil)$       (ofScore2 nil)$$       ;permuted ofScore$       (permOfScore0 nil)$       (permOfScore1 nil)$       (permOfScore2 nil)$$      $       ;var$       (scoreVar0 nil)$       (scoreVar1 nil)$       (scoreVar2 nil)$$       ;different solution steps$       (solScoreRel0 nil)$       (solScoreRel1 nil)$       (solScoreRel2 nil)$$      ;search engine$      (se nil)$$      ;solution$      (sol1 nil)$$     )$    $    (print \"After the let !\")$$    ;axiom$    (GRelation-AddTuple gm glbAxiom (newTuple gm '(1 1))) ; first pattern is played on onset 1$    (setq axiomVar (newCPRelVar gm sp glbAxiom glbAxiom))$    $    ;scores as relations between patterns and offsets in time (onset)$    (setq lubOfPat (GRelation-Times gm onsets patternIds))$    (setq ofPat0 (newCPRelVar gm sp glbOfPat lubOfPat))$    (setq ofPat1 (newCPRelVar gm sp glbOfPat lubOfPat))$    (setq ofPat2 (newCPRelVar gm sp glbOfPat lubOfPat))$$$    ; Relation Offset | Score (Pitch, Duration, Onset)$    (setq lubOfScore (GRelation-Times gm (GRelation-Times gm onsets pitches) (GRelation-Times gm durations onsets)))$    (setq ofScore0 (newCPRelVar gm sp glbOfScore lubOfScore))$    (setq ofScore1 (newCPRelVar gm sp glbOfScore lubOfScore))$    (setq ofScore2 (newCPRelVar gm sp glbOfScore lubOfScore))$$    $    ;permuted Relation Offset | Score (Pitch, Duration, Onset)$    (setq lubPermutOfScore (GRelation-Times gm (GRelation-Times gm durations pitches) (GRelation-Times gm onsets onsets)))$    (setq permOfScore0 (newCPRelVar gm sp glbPermutOfScore lubPermutOfScore))$    (setq permOfScore1 (newCPRelVar gm sp glbPermutOfScore lubPermutOfScore))$    (setq permOfScore2 (newCPRelVar gm sp glbPermutOfScore lubPermutOfScore))$$$    ;scores$    (setq lubScore (GRelation-Times gm durations (GRelation-Times gm pitches onsets )))$    (setq scoreVar0 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar1 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar2 (newCPRelVar gm sp glbScore lubScore))$    $    (print \"before constraints !\")$$$    ;constraints$$    ;axiom is the first score$    (equalConstraint gm sp axiomVar ofPat0)$$    ;generation of the score from the relations ofPat$   $    ;link subscore with corresponding offset $    (followConstraint gm sp ofPat0 1 patternsVar ofScore0)$    (followConstraint gm sp ofPat1 1 patternsVar ofScore1)$    (followConstraint gm sp ofPat2 1 patternsVar ofScore2)$    ;permute those link$    (permutationConstraint gm sp ofScore0 permOfScore0 '((1 3))) ; duration | pitch | onset | offset$    (permutationConstraint gm sp ofScore1 permOfScore1 '((1 3)))$    (permutationConstraint gm sp ofScore2 permOfScore2 '((1 3)))$$$    ;reconstruct the scores by adding the offset to the onset parameter$    (followConstraint gm sp permOfScore0 2 plusVar scoreVar0)$    (followConstraint gm sp permOfScore1 2 plusVar scoreVar1)$    (followConstraint gm sp permOfScore2 2 plusVar scoreVar2)$   $$   $$$$    ;lindenmayer part$    $$$$    ;branching $    (branch gm sp scoreVar0)$    (branch gm sp scoreVar1)$    (branch gm sp scoreVar2)$$    (print \"before print\")$    ;print$    ;(printSpace gm sp)$    $    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel0 (getVarInSpace gm sol1 scoreVar0))$          (setq solScoreRel1 (getVarInSpace gm sol1 scoreVar1))$          (setq solScoreRel2 (getVarInSpace gm sol1 scoreVar2))$  $     )$     ;else$     ()$    )$$    (print (list solScoreRel0 solScoreRel1 solScoreRel2))$)$$$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil) (om-load-inputfun (quote input-funbox) "" "PLUSREL" nil) (om-load-inputfun (quote input-funbox) "" "PATTERNSANDPATTERNIDS" nil) (om-load-inputfun (quote input-funbox) "" "RULES" nil) (om-load-inputfun (quote input-funbox) "" "PITCHONSETDURATION" nil))) (om-make-point 410 352) nil nil "&" "problem definition") (om-load-boxcall (quote abstraction) "create rules" (om-load-lisp-abspatch "create rules" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $  $  (let $      ($       (rulePO (newGRelation gm 4)); pattern1 | onset1 | pattern2 | onset2$       (ruleP (newGRelation gm 2)) ; pattern1 | pattern2$       (ruleList nil)$       )$$$    ;Rules on pattern and onset combined$    (GRelation-AddTuple gm rulePO (newTuple gm '(1 1 2 4)))$    $    ;Rules on pattern$    (GRelation-AddTuple gm ruleP (newTuple gm '(2 3)))$$    ;return$    (setq ruleList (list rulePO ruleP))$$)$  $$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 654 135) nil nil "&" "create rules") (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 504 30) (om-make-point 28 30) 20 "20" nil) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 455 29) (om-make-point 21 30) 0 "0" nil) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 414 30) (om-make-point 28 30) 20 "20" nil) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 367 31) (om-make-point 21 30) 0 "0" nil) (om-load-boxcall (quote abstraction) "create patterns" (om-load-lisp-abspatch "create patterns" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create patterns\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$$$; The patterns come from the example provided by Torsten Anders. Here they are fixed.$(lambda (gm)$$  (let $      ($       (patterns (newGRelation gm 4)); Pattern | Pitch | Duration | Onset$       (patternsAndPatternIds nil)$       )$$$    ;Pattern1 (run)$    (GRelation-AddTuple gm patterns (newTuple gm '(1 48 1 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(1 50 1 2)))$    (GRelation-AddTuple gm patterns (newTuple gm '(1 52 1 3)))$    (GRelation-AddTuple gm patterns (newTuple gm '(1 53 1 4)))$$    ;Pattern2 (chord repetition)$    (GRelation-AddTuple gm patterns (newTuple gm '(2 48 3 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 59 3 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 64 3 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 67 3 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 48 3 4)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 59 3 4)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 64 3 4)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 67 3 4)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 48 3 7)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 59 3 7)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 64 3 7)))$    (GRelation-AddTuple gm patterns (newTuple gm '(2 67 3 7)))$$    ;Pattern3 (arpeggio)$    (GRelation-AddTuple gm patterns (newTuple gm '(3 55 2 1)))$    (GRelation-AddTuple gm patterns (newTuple gm '(3 52 2 3)))$    (GRelation-AddTuple gm patterns (newTuple gm '(3 48 2 5)))$    $    ;return$    (setq patternsAndPatternIds (list patterns (first (createBoundedFullGroundRelation gm '((1 3))))))$    )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 523 136) nil nil "&" "create patterns") (om-load-boxcall (quote abstraction) "create plus" (om-load-lisp-abspatch "create plus" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create plus\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm minX maxX minY maxY)$$  (let ($          (plusRel (createGroundRelFromTupleUUIDList gm (createTupleUUIDListFromLispTupleList gm (createBoundedPlus (list minX maxX) (list minY maxY)))))$        )$$    (setq plusRel plusRel)$$  )$$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "MINX" 0) (om-load-inputfun (quote input-funbox) "" "MAXX" nil) (om-load-inputfun (quote input-funbox) "" "MINY" nil) (om-load-inputfun (quote input-funbox) "" "MAXY" nil))) (om-make-point 413 139) nil nil "&" "create plus") (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 256 928) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 290 140) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 128 42) nil nil "&" "create Gecode manager") (om-load-boxcall (quote bastype) "string 4" (quote string) (quote nil) (om-make-point 900 992) (om-make-point 959 30) "The advantage here is that we don't have to fix the pattern directly. We can add constraint on the resulting score, and the pattern will be modified to fit our needs !" "\"The advantage here is that we don't have to fix the pattern directly. We can add constraint on the resulting score, and the pattern will be modified to fit our needs !\"" nil) (om-load-boxcall (quote bastype) "string 3" (quote string) (quote nil) (om-make-point 1205 919) (om-make-point 290 30) "the l-system is then applied on the pattern IDs" "\"the l-system is then applied on the pattern IDs\"" nil) (om-load-boxcall (quote bastype) "string 2" (quote string) (quote nil) (om-make-point 1210 851) (om-make-point 643 30) "to represent the actual patterns, we simply use a relation with an ID component (the number of the pattern)" "\"to represent the actual patterns, we simply use a relation with an ID component (the number of the pattern)\"" nil) (om-load-boxcall (quote bastype) "string" (quote string) (quote nil) (om-make-point 1215 795) (om-make-point 264 30) "a pattern is just represented by a number" "\"a pattern is just represented by a number\"" nil))) (quote ((12 0 0 0 nil 0) (11 0 0 1 nil 0) (8 0 1 0 nil 0) (7 0 1 1 nil 0) (4 0 2 0 nil 0) (5 0 4 0 nil 0) (3 0 4 1 nil 0) (22 0 5 0 nil 0) (1 0 6 0 nil 0) (22 0 8 0 nil 0) (2 0 9 0 nil 0) (6 0 9 1 nil 0) (10 0 9 2 nil 0) (0 0 10 0 nil 0) (22 0 12 0 nil 0) (15 0 16 0 nil 0) (14 0 16 1 nil 0) (27 0 17 0 nil 0) (26 0 17 1 nil 0) (19 0 20 0 nil 0) (18 0 20 1 nil 0) (32 0 21 0 nil 0) (20 0 21 1 nil 0) (17 0 21 2 nil 0) (16 0 21 3 nil 0) (32 0 22 0 nil 0) (31 0 22 1 nil 0) (29 0 22 2 nil 0) (28 0 22 3 nil 0) (23 0 22 4 nil 0) (21 0 22 5 nil 0) (32 0 23 0 nil 0) (32 0 28 0 nil 0) (32 0 29 0 nil 0) (27 0 29 1 nil 0) (26 0 29 2 nil 0) (25 0 29 3 nil 0) (24 0 29 4 nil 0) (32 0 30 0 nil 0) (9 0 30 1 nil 0) (32 0 31 0 nil 0))) nil 6.050003))
