; OM File Header - Saved 2012/07/05 17:47:53
; (6.050003 :patc (om-make-point 10 10) (om-make-point 0 0) (om-make-point 1920 1156) "" 183 0 "2012/06/14 14:25:45" "2012/06/18 18:55:36")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "lindenmayer1" (quote ((om-load-boxcall (quote bastype) "string 7" (quote string) (quote nil) (om-make-point 675 1041) (om-make-point 966 30) "Also, we could try to find the axiom from an existing result and a set of given rule. (but then the rules must don't loose any information when going from left to right" "\"Also, we could try to find the axiom from an existing result and a set of given rule. (but then the rules must don't loose any information when going from left to right\"" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 686 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 834 341) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote abstraction) "rel as score 3" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 690 431) nil nil "&" "rel as score") (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 650 540) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6000) (6000) (6400) (6400) (6700) (6700))) :lonset (quote (500 1000 1500 500 1000 500 1000 1500)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 485 47) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote lispfun) "LIST 3" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 376 662) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 508 277) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "rel as score 2" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 470 423) nil nil "&" "rel as score") (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 614 333) (om-make-point 21 30) 1 "1" nil) (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 436 542) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6000) (6400) (6700))) :lonset (quote (500 1000 500 500 1000)) :ldur (quote ((1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 22) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 321 275) nil nil nil nil 1) (om-load-boxcall (quote bastype) "string 5" (quote string) (quote nil) (om-make-point 663 1078) (om-make-point 754 30) "if need to transform one element with consecutive element (in space or in time), simply use a time/space additional component" "\"if need to transform one element with consecutive element (in space or in time), simply use a time/space additional component\"" nil) (om-load-boxcall (quote bastype) "string 6" (quote string) (quote nil) (om-make-point 659 1011) (om-make-point 1013 30) "possible to build an l-system from initial state and final state, provided we know the number of recursion. Indeed, if a rule is used somewhere, it must be used everywhere !" "\"possible to build an l-system from initial state and final state, provided we know the number of recursion. Indeed, if a rule is used somewhere, it must be used everywhere !\"" nil) (om-load-boxcall (quote bastype) "string 4" (quote string) (quote nil) (om-make-point 669 799) (om-make-point 319 30) "A set of rule is just the union of those rule-relations" "\"A set of rule is just the union of those rule-relations\"" nil) (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 192 865) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 142 33) nil nil "&" "create Gecode manager") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 464 79) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "lindenmayer" (om-load-lisp-abspatch "lindenmayer" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp) $$  (let$$      ($       (glbScore (newGRelation gm 2))$       (pitches (first (createBoundedFullGroundRelation gm '((60 72)))))$       (onsets (first (createBoundedFullGroundRelation gm '((1 16)))))$       ;(duration (first (createBoundedFullGroundRelation gm '((1 4)))))$       $       (glbAxiom (newGRelation gm 2))$       (axiomVar nil)$$       (lubScore nil)$$$       ;different steps of the \"score lindenmayer evolution\"$       (scoreVar0 nil)$       (scoreVar1 nil)$       (scoreVar2 nil)$       (scoreVar3 nil)$       $       ;the different rules (here we only transform pitch to pitch, onset to onset, and pitch-onset to pitch-onset)$       ;glbs$       (glbUnaryRule (newGRelation gm 2)) ;pitch to pitch and onset to onset$       (glbBinaryRule (newGRelation gm 4)) ;note to note$$       ;lubs$       (lubRule1 (newGRelation gm 2))$       (lubRule2 (newGRelation gm 4))$       (lubRule3 nil)$       (lubRule4 nil)$       (lubRule5 nil)$$       ;the actual rules$       (Rule1Var nil)$       (Rule2Var nil)$       (Rule3Var nil)$       (Rule4Var nil)$       (Rule5Var nil)$$       (se nil)$$       ;different solution steps$       (solScoreRel0 nil)$       (solScoreRel1 nil)$       (solScoreRel2 nil)$       (solScoreRel3 nil)$     $$       ;auxilary ground relations$       (pitchPitch (newGRelation gm 2)) ; will link a pitch value with the same pitch value, used for note transformation$       (nNplus1 (newGRelation gm 2))$       (grRuleNote nil)$       $       ;auxilary ground relations$       (scoreVar0PT nil)$       (scoreVar0NT nil)$       (scoreVar1PT nil)$       (scoreVar1NT nil)$       $       $$      )$$    $$$    ;the axiom$    (GRelation-AddTuple gm glbAxiom (newTuple gm '(1 60)))$    (setq axiomVar (newCPRelVar gm sp glbAxiom glbAxiom))$$    ;the score$    ;(setq lubScore (GRelation-Times gm (GRelation-Times gm duration onsets) pitches))$    (setq lubScore (GRelation-Times gm onsets pitches))$    (setq scoreVar0 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar1 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar2 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar3 (newCPRelVar gm sp glbScore lubScore))$$    ;the rules$$    ;rule1 (on pitch)$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(60 60)))$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(60 64)))$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(60 67)))  $    (setq Rule1Var (newCPRelVar gm sp lubRule1 lubRule1))$    $$    ;rule2 (on notes)$    ;auxilary ground relations$    ;;pitchPitch$    (loop for i from 60 to 72 do$          (GRelation-AddTuple gm pitchPitch (newTuple gm (list i i)))$          )$    ;;nNplus1$    (loop for i from 1 to 20 do$          (GRelation-AddTuple gm nNplus1 (newTuple gm (list i (+ i 1))))$          )$    $    (setq grRuleNote (GRelation-Permute gm (GRelation-Times gm nNplus1 pitchPitch) '((1 2))))$    (setq Rule2Var (newCPRelVar gm sp grRuleNote grRuleNote))$ $    $$$$$$    ;constraints$    ;the first score is the axiom$    (equalConstraint gm sp axiomVar scoreVar0)$$    ;the second var is created from the first one$    ;auxiliary variables$    (setq scoreVar0PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar0NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar0 1 Rule1Var scoreVar0PT)$    (followConstraint gm sp scoreVar0 2 Rule2Var scoreVar0NT)$    (unionConstraint gm sp scoreVar0PT scoreVar0NT scoreVar1)$$    ;the third score is created from the second one$    ;auxiliary variables$    (setq scoreVar1PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar1NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar1 1 Rule1Var scoreVar1PT)$    (followConstraint gm sp scoreVar1 2 Rule2Var scoreVar1NT)$    (unionConstraint gm sp scoreVar1PT scoreVar1NT scoreVar2)$    $    $    $$$$$$$$$$$    ;branching $    (branch gm sp scoreVar0)$    (branch gm sp scoreVar1)$$    ;print$    (printSpace gm sp)$    $    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel0 (getVarInSpace gm sol1 scoreVar0))$          (setq solScoreRel1 (getVarInSpace gm sol1 scoreVar1))$          (setq solScoreRel2 (getVarInSpace gm sol1 scoreVar2))$  $     )$     ;else$     ()$    )$$    (print (list solScoreRel0 solScoreRel1 solScoreRel2))$     $$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil))) (om-make-point 355 211) nil nil "&" "lindenmayer") (om-load-boxcall (quote abstraction) "rel as score" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 280 420) nil nil "&" "rel as score") (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 424 330) (om-make-point 21 30) 1 "1" nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 246 539) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (500 1500)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 22) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote bastype) "string 3" (quote string) (quote nil) (om-make-point 665 935) (om-make-point 527 30) "we can consider learning the rules from existing scores and appliying them on new data" "\"we can consider learning the rules from existing scores and appliying them on new data\"" nil) (om-load-boxcall (quote bastype) "string 2" (quote string) (quote nil) (om-make-point 666 882) (om-make-point 629 30) "What is new is that those rules can be undefined when we start the search !!! (if the relation is a variable)" "\"What is new is that those rules can be undefined when we start the search !!! (if the relation is a variable)\"" nil) (om-load-boxcall (quote bastype) "string" (quote string) (quote nil) (om-make-point 673 741) (om-make-point 449 30) "A rule is defined as a relation (or a tuple), used with a compose constraint" "\"A rule is defined as a relation (or a tuple), used with a compose constraint\"" nil))) (quote ((17 0 1 0 nil 0) (1 0 3 0 nil 0) (2 0 3 1 nil 0) (3 0 4 0 nil 0) (20 0 5 0 nil 0) (9 0 5 1 nil 0) (4 0 5 2 nil 0) (17 0 6 0 nil 0) (6 0 7 0 nil 0) (8 0 7 1 nil 0) (7 0 9 0 nil 0) (17 0 10 0 nil 0) (15 0 14 0 nil 0) (5 0 14 1 nil 0) (15 0 16 0 nil 0) (15 0 17 0 nil 0) (16 0 17 1 nil 0) (10 0 18 0 nil 0) (19 0 18 1 nil 0) (18 0 20 0 nil 0))) nil 6.050003))
