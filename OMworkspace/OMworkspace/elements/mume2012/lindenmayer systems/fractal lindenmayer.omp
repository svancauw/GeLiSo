; OM File Header - Saved 2012/07/05 17:47:51
; (6.050003 :patc (om-make-point 10 10) (om-make-point 0 0) (om-make-point 1280 980) "" 183 0 "2012/07/05 15:49:39" "2012/07/05 17:47:38")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "fractal lindenmayer" (quote ((om-load-boxcall (quote lispfun) "LIST 3" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 390 668) nil nil nil nil 1) (om-load-editor-box1 "MULTI-SEQ" (quote multi-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "list of CHORD-SEQ objects" "chord-seqs" (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj))))) (om-make-point 380 746) (om-make-point 130 65) (if (find-class (quote multi-seq) nil) (let ((newobj (make-instance (quote multi-seq) :chord-seqs (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7400) (7100) (6700) (6900))) :lonset (quote (500 8500 16500 24500 36500)) :ldur (quote ((8000) (8000) (8000) (8000))) :lvel (quote ((100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6200) (6200) (7100) (6700) (6900) (7400) (6700) (7100) (6400) (6500) (6700) (6400) (6500) (6900) (6400))) :lonset (quote (20500 22500 28500 2500 4500 6500 500 10500 8500 12500 14500 16500 18500 26500 24500 30500 36500)) :ldur (quote ((4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6200) (6200) (6000) (5700) (5900) (5900) (6000) (6200) (6200) (5300) (5500) (5500) (5700) (6000) (6000) (6000) (6200) (5700) (5900) (5900) (6000) (6200) (5500) (5700) (5900) (6200) (6200) (5900) (5700) (5700) (6000) (6200) (6000) (5900) (6700) (6400) (6700) (7100) (6900) (7100) (6500) (6400) (6700) (6500) (6900) (7400) (6400) (6400) (6700) (6500) (6400) (6700) (7100) (6400) (6500) (6400) (6700) (6400) (6500) (6400) (6500) (6900) (6400))) :lonset (quote (5500 6000 7500 11500 13500 14000 15500 13000 12000 15000 21500 22000 23500 19500 16000 17500 19000 18000 21000 20000 23000 20500 22500 29500 24000 27500 25500 27000 29000 30000 31500 28000 28500 31000 32000 1500 3500 3000 1000 2000 2500 4000 5000 4500 7000 6500 500 8000 9500 9000 10000 11000 10500 8500 12500 14500 17000 16500 18500 25000 26000 26500 24500 30500 36500)) :ldur (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) :from-file t))) (load-port-info newobj (quote (((0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)) ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 0) (om-make-point 1280 980) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1 1 1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (list (quote g) (quote g) (quote g)) 24 2)) t nil nil nil) (om-load-boxcall (quote abstraction) "rel as score 6" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 785 214) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 0 0 nil 0) (8 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 4 1 nil 0) (2 0 4 2 nil 0) (0 0 4 3 nil 0) (3 0 4 6 nil 0) (4 0 6 0 nil 0) (5 0 7 0 nil 0) (7 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (11 0 10 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 1474 410) nil nil "&" "rel as score") (om-load-boxcall (quote abstraction) "rel as score 5" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 785 214) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 0 0 nil 0) (8 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 4 1 nil 0) (2 0 4 2 nil 0) (0 0 4 3 nil 0) (3 0 4 6 nil 0) (4 0 6 0 nil 0) (5 0 7 0 nil 0) (7 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (11 0 10 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 1210 408) nil nil "&" "rel as score") (om-load-boxcall (quote abstraction) "rel as score 4" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 785 214) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 0 0 nil 0) (8 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 4 1 nil 0) (2 0 4 2 nil 0) (0 0 4 3 nil 0) (3 0 4 6 nil 0) (4 0 6 0 nil 0) (5 0 7 0 nil 0) (7 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (11 0 10 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 965 405) nil nil "&" "rel as score") (om-load-boxcall (quote abstraction) "rel as score 3" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 785 214) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 0 0 nil 0) (8 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 4 1 nil 0) (2 0 4 2 nil 0) (0 0 4 3 nil 0) (3 0 4 6 nil 0) (4 0 6 0 nil 0) (5 0 7 0 nil 0) (7 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (11 0 10 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 689 403) nil nil "&" "rel as score") (om-load-boxcall (quote abstraction) "rel as score 2" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 785 214) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 0 0 nil 0) (8 0 2 0 nil 0) (1 0 2 1 nil 0) (10 0 4 1 nil 0) (2 0 4 2 nil 0) (0 0 4 3 nil 0) (3 0 4 6 nil 0) (4 0 6 0 nil 0) (5 0 7 0 nil 0) (7 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (11 0 10 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 476 433) nil nil "&" "rel as score") (om-load-boxcall (quote lispfun) "SIXTH" (quote sixth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 1444 277) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ 6" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 1437 548) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote nil) :lonset (quote (0)) :ldur (quote nil) :lvel (quote nil) :loffset (quote nil) :lchan (quote nil) :legato 0)))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 292 1206) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 1621 349) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "FIFTH" (quote fifth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 1192 287) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ 5" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 1205 543) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote nil) :lonset (quote (0)) :ldur (quote nil) :lvel (quote nil) :loffset (quote nil) :lchan (quote nil) :legato 0)))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 291 1230) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 1389 344) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "FOURTH" (quote fourth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 931 300) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ 4" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 939 549) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote nil) :lonset (quote (0)) :ldur (quote nil) :lvel (quote nil) :loffset (quote nil) :lchan (quote nil) :legato 0)))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 0 1024) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 1123 350) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 686 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 834 341) (om-make-point 21 30) 1 "1" nil) (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 650 540) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6200) (6200) (6000) (5700) (5900) (5900) (6000) (6200) (6200) (5300) (5500) (5500) (5700) (6000) (6000) (6000) (6200) (5700) (5900) (5900) (6000) (6200) (5500) (5700) (5900) (6200) (6200) (5900) (5700) (5700) (6000) (6200) (6000) (5900) (6700) (6400) (6700) (7100) (6900) (7100) (6500) (6400) (6700) (6500) (6900) (7400) (6400) (6400) (6700) (6500) (6400) (6700) (7100) (6400) (6500) (6400) (6700) (6400) (6500) (6400) (6500) (6900) (6400))) :lonset (quote (5500 6000 7500 11500 13500 14000 15500 13000 12000 15000 21500 22000 23500 19500 16000 17500 19000 18000 21000 20000 23000 20500 22500 29500 24000 27500 25500 27000 29000 30000 31500 28000 28500 31000 32000 1500 3500 3000 1000 2000 2500 4000 5000 4500 7000 6500 500 8000 9500 9000 10000 11000 10500 8500 12500 14500 17000 16500 18500 25000 26000 26500 24500 30500 36500)) :ldur (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 0 1024) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 508 277) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 614 333) (om-make-point 21 30) 1 "1" nil) (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 436 542) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6200) (6200) (7100) (6700) (6900) (7400) (6700) (7100) (6400) (6500) (6700) (6400) (6500) (6900) (6400))) :lonset (quote (20500 22500 28500 2500 4500 6500 500 10500 8500 12500 14500 16500 18500 26500 24500 30500 36500)) :ldur (quote ((4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4) (4))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 0 22) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 321 275) nil nil nil nil 1) (om-load-boxcall (quote bastype) "string 5" (quote string) (quote nil) (om-make-point 663 1078) (om-make-point 754 30) "if need to transform one element with consecutive element (in space or in time), simply use a time/space additional component" "\"if need to transform one element with consecutive element (in space or in time), simply use a time/space additional component\"" nil) (om-load-boxcall (quote bastype) "string 6" (quote string) (quote nil) (om-make-point 659 1011) (om-make-point 1013 30) "possible to build an l-system from initial state and final state, provided we know the number of recursion. Indeed, if a rule is used somewhere, it must be used everywhere !" "\"possible to build an l-system from initial state and final state, provided we know the number of recursion. Indeed, if a rule is used somewhere, it must be used everywhere !\"" nil) (om-load-boxcall (quote bastype) "string 4" (quote string) (quote nil) (om-make-point 669 799) (om-make-point 319 30) "A set of rule is just the union of those rule-relations" "\"A set of rule is just the union of those rule-relations\"" nil) (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 192 867) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 142 33) nil nil "&" "create Gecode manager") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 464 79) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "lindenmayer" (om-load-lisp-abspatch "lindenmayer" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp) $$  (let$$      ($       (glbScore (newGRelation gm 3))$       (pitches (first (createBoundedFullGroundRelation gm '((53 84)))))$       (onsets (first (createBoundedFullGroundRelation gm '((1 100)))))$       (duration (first (createBoundedFullGroundRelation gm '((1 16)))))$       $       (glbAxiom (newGRelation gm 3))$       (axiomVar nil)$$       (lubScore nil)$$$       ;different steps of the \"score lindenmayer evolution\"$       (scoreVar0 nil)$       (scoreVar1 nil)$       (scoreVar2 nil)$       (scoreVar3 nil)$       (scoreVar4 nil)$       (scoreVar5 nil)$       $       ;glbs$       (glbUnaryRule (newGRelation gm 2)) ;pitch to pitch and onset to onset$       (glbTernaryRule (newGRelation gm 6)) ;note to note$$       ;lubs$       (lubRule1 (newGRelation gm 2))$       (lubRule2 (newGRelation gm 6))$$       ;the actual rules$       (Rule1Var nil)$       (Rule2Var nil)$$       (se nil)$$       ;different solution steps$       (solScoreRel0 nil)$       (solScoreRel1 nil)$       (solScoreRel2 nil)$       (solScoreRel3 nil)$       (solScoreRel4 nil)$       (solScoreRel5 nil)$     $$       ;auxilary ground relations$       (pitchPitch (newGRelation gm 2)) ; will link a pitch value with the same pitch value, used for note transformation$       (nNplus1 (newGRelation gm 2))$       (grRuleNote nil)$       $       ;auxilary ground relations$       (scoreVar0PT nil)$       (scoreVar0NT nil)$       (scoreVar1PT nil)$       (scoreVar1NT nil)$       (scoreVar2PT nil)$       (scoreVar2NT nil)$       (scoreVar3PT nil)$       (scoreVar3NT nil)$       (scoreVar4PT nil)$       (scoreVar4NT nil)$$       $       $$      )$$    $$$    ;the axiom (from is fractal music ?)$    (GRelation-AddTuple gm glbAxiom (newTuple gm '(1 74 16)))$    (GRelation-AddTuple gm glbAxiom (newTuple gm '(17 71 16)))$    (GRelation-AddTuple gm glbAxiom (newTuple gm '(33 67 16)))$    (GRelation-AddTuple gm glbAxiom (newTuple gm '(49 69 16)))$$    (setq axiomVar (newCPRelVar gm sp glbAxiom glbAxiom))$$    ;the score$    (setq lubScore (GRelation-Times gm (GRelation-Times gm onsets pitches) duration))$    ;(setq lubScore (GRelation-Times gm onsets pitches))$    (setq scoreVar0 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar1 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar2 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar3 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar4 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar5 (newCPRelVar gm sp glbScore lubScore))$$    ;the rules$$    ;rule1 (on pitch)$    #|(GRelation-AddTuple gm lubRule1 (newTuple gm '(60 60)))$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(60 64)))$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(60 67)))$$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(64 67)))$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(64 70)))$    $    (GRelation-AddTuple gm lubRule1 (newTuple gm '(67 72))) $$    (setq Rule1Var (newCPRelVar gm sp lubRule1 lubRule1))|#$    $$    ;rule2 (on notes)$    ;auxilary ground relations$    ;;pitchPitch$    #|(loop for i from 60 to 72 do$          (GRelation-AddTuple gm pitchPitch (newTuple gm (list i i)))$          )$    ;;nNplus1$    (loop for i from 1 to 20 do$          (GRelation-AddTuple gm nNplus1 (newTuple gm (list i (+ i 1))))$          )$   $$    (setq grRuleNote (GRelation-Permute gm (GRelation-Times gm nNplus1 pitchPitch) '((1 2))))$$    $$    (setq grRuleNote (newGRelation gm 4))$$    (print \"before loop\")$$    (loop for i from 1 to 100 do$          (loop for j from 0 to 24 do $                (print (list i (+ 60 j) (+ i j) (+ 60 j)))$                (GRelation-AddTuple gm grRuleNote (newTuple gm (list i (+ 60 j) (+ i j) (+ 60 j))))$                )$          )$$    |#$$    ;fractal rules on notes$    $    (setq grRuleNote (newGRelation gm 6))$$    (loop for i from 1 to 100 do$          (print i)$          (let ($                (j 16)$                )$            $            (loop while (> j 1) do$             $                  ;pitch 74$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 74 j i  74 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 74 j (+ i (* 1 (/ j 4))) 71 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 74 j (+ i (* 2 (/ j 4))) 67 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 74 j (+ i (* 3 (/ j 4))) 69 (/ j 4))))$$                  ;pitch 71$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 71 j i  71 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 71 j (+ i (* 1 (/ j 4))) 67 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 71 j (+ i (* 2 (/ j 4))) 64 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 71 j (+ i (* 3 (/ j 4))) 65 (/ j 4))))$$                  ;pitch 67$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 67 j i  67 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 67 j (+ i (* 1 (/ j 4))) 64 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 67 j (+ i (* 2 (/ j 4))) 60 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 67 j (+ i (* 3 (/ j 4))) 62 (/ j 4))))$$                  ;pitch 69$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 69 j i  69 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 69 j (+ i (* 1 (/ j 4))) 65 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 69 j (+ i (* 2 (/ j 4))) 62 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 69 j (+ i (* 3 (/ j 4))) 64 (/ j 4))))$$                  ;pitch 64$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 64 j i  64 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 64 j (+ i (* 1 (/ j 4))) 60 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 64 j (+ i (* 2 (/ j 4))) 57 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 64 j (+ i (* 3 (/ j 4))) 59 (/ j 4))))$$                  ;pitch 65$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 65 j i  65 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 65 j (+ i (* 1 (/ j 4))) 62 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 65 j (+ i (* 2 (/ j 4))) 59 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 65 j (+ i (* 3 (/ j 4))) 60 (/ j 4))))$$                  ;pitch 60$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 60 j i  60 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 60 j (+ i (* 1 (/ j 4))) 57 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 60 j (+ i (* 2 (/ j 4))) 53 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 60 j (+ i (* 3 (/ j 4))) 55 (/ j 4))))$$                  ;pitch 62$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 62 j i  62 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 62 j (+ i (* 1 (/ j 4))) 59 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 62 j (+ i (* 2 (/ j 4))) 55 (/ j 4))))$                  (GRelation-AddTuple gm grRuleNote (newTuple gm (list i 62 j (+ i (* 3 (/ j 4))) 57 (/ j 4))))$$           $$                  (setq j (/ j 4))$            )$            $            )$          )$$$$$$    (print \"after loop\")$$    (setq Rule2Var (newCPRelVar gm sp grRuleNote grRuleNote))$ $    $    (print \"before constraints\")$$$$$    ;constraints$    ;the first score is the axiom$    (equalConstraint gm sp axiomVar scoreVar0)$$    #|$    ;the second var is created from the first one$    ;auxiliary variables$    (setq scoreVar0PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar0NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar0 1 Rule1Var scoreVar0PT)$    (followConstraint gm sp scoreVar0 2 Rule2Var scoreVar0NT)$    (unionConstraint gm sp scoreVar0PT scoreVar0NT scoreVar1)$$    ;the third score is created from the second one$    ;auxiliary variables$    (setq scoreVar1PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar1NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar1 1 Rule1Var scoreVar1PT)$    (followConstraint gm sp scoreVar1 2 Rule2Var scoreVar1NT)$    (unionConstraint gm sp scoreVar1PT scoreVar1NT scoreVar2)$    $    ;the fourth score is created from the third one$    ;auxiliary variables$    (setq scoreVar2PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar2NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar2 1 Rule1Var scoreVar2PT)$    (followConstraint gm sp scoreVar2 2 Rule2Var scoreVar2NT)$    (unionConstraint gm sp scoreVar2PT scoreVar2NT scoreVar3)$$    ;the fifth score is created from the fourth one$    ;auxiliary variables$    (setq scoreVar3PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar3NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar3 1 Rule1Var scoreVar3PT)$    (followConstraint gm sp scoreVar3 2 Rule2Var scoreVar3NT)$    (unionConstraint gm sp scoreVar3PT scoreVar3NT scoreVar4)$$    ;the sixth score is created from the fourth one$    ;auxiliary variables$    (setq scoreVar4PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar4NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar4 1 Rule1Var scoreVar4PT)$    (followConstraint gm sp scoreVar4 2 Rule2Var scoreVar4NT)$    (unionConstraint gm sp scoreVar4PT scoreVar4NT scoreVar5)$    |#$$    ;the second var is created from the first one$    (followConstraint gm sp scoreVar0 3 Rule2Var scoreVar1)$    $    ;the third score is created from the second one$    (followConstraint gm sp scoreVar1 3 Rule2Var scoreVar2)$$    ;the fourth score is created from the third one$    (followConstraint gm sp scoreVar2 3 Rule2Var scoreVar3)$$    ;the fifth score is created from the fourth one$    (followConstraint gm sp scoreVar3 3 Rule2Var scoreVar4)$$    ;the sixth score is created from the fourth one$    (followConstraint gm sp scoreVar4 3 Rule2Var scoreVar5)$$$    $$$    (print \"after constraints\")$$$$$$$$    ;branching $    (branch gm sp scoreVar0)$    (branch gm sp scoreVar1)$$$    (print \"before print\")$    ;print$    ;(printSpace gm sp)$    $    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel0 (getVarInSpace gm sol1 scoreVar0))$          (setq solScoreRel1 (getVarInSpace gm sol1 scoreVar1))$          (setq solScoreRel2 (getVarInSpace gm sol1 scoreVar2))$          (setq solScoreRel3 (getVarInSpace gm sol1 scoreVar3))$          (setq solScoreRel4 (getVarInSpace gm sol1 scoreVar4))$          (setq solScoreRel5 (getVarInSpace gm sol1 scoreVar5))$  $     )$     ;else$     ()$    )$$    (print (list solScoreRel0 solScoreRel1 solScoreRel2 solScoreRel3 solScoreRel4 solScoreRel5))$     $$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil))) (om-make-point 381 184) nil nil "&" "lindenmayer") (om-load-boxcall (quote abstraction) "rel as score" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 833 265) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 884 214) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 785 214) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 311 -671) 0 1 (quote t) nil 0)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((2 0 0 0 nil 0) (1 0 0 1 nil 0) (9 0 2 0 nil 0) (10 0 4 0 nil 0) (3 0 4 1 nil 0) (12 0 6 1 nil 0) (4 0 6 2 nil 0) (0 0 6 3 nil 0) (5 0 6 6 nil 0) (6 0 8 0 nil 0) (7 0 9 0 nil 0) (9 0 10 0 nil 0) (9 0 11 0 nil 0) (11 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 0 0) (om-make-point 1280 980)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 280 420) nil nil "&" "rel as score") (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 424 330) (om-make-point 21 30) 1 "1" nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 259 539) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((7400) (7100) (6700) (6900))) :lonset (quote (500 8500 16500 24500 32500)) :ldur (quote ((8000) (8000) (8000) (8000))) :lvel (quote ((100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode show-stems scale palette-mode)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil 0 (quote :midishare) 1 nil 1000 0 (om-make-point 1280 752) (om-make-point 0 1024) 0 1 (quote t) nil 0)) t nil nil nil) (om-load-boxcall (quote bastype) "string 3" (quote string) (quote nil) (om-make-point 665 935) (om-make-point 527 30) "we can consider learning the rules from existing scores and appliying them on new data" "\"we can consider learning the rules from existing scores and appliying them on new data\"" nil) (om-load-boxcall (quote bastype) "string 2" (quote string) (quote nil) (om-make-point 666 882) (om-make-point 629 30) "What is new is that those rules can be undefined when we start the search !!! (if the relation is a variable)" "\"What is new is that those rules can be undefined when we start the search !!! (if the relation is a variable)\"" nil) (om-load-boxcall (quote bastype) "string" (quote string) (quote nil) (om-make-point 673 741) (om-make-point 449 30) "A rule is defined as a relation (or a tuple), used with a compose constraint" "\"A rule is defined as a relation (or a tuple), used with a compose constraint\"" nil))) (quote ((32 0 0 0 nil 0) (21 0 0 1 nil 0) (18 0 0 2 nil 0) (0 0 1 1 nil 0) (7 0 2 0 nil 0) (12 0 2 1 nil 0) (10 0 3 0 nil 0) (9 0 3 1 nil 0) (13 0 4 0 nil 0) (15 0 4 1 nil 0) (16 0 5 0 nil 0) (17 0 5 1 nil 0) (19 0 6 0 nil 0) (20 0 6 1 nil 0) (29 0 7 0 nil 0) (2 0 8 0 nil 0) (29 0 10 0 nil 0) (3 0 11 0 nil 0) (29 0 13 0 nil 0) (4 0 14 0 nil 0) (29 0 16 0 nil 0) (5 0 18 0 nil 0) (29 0 19 0 nil 0) (6 0 21 0 nil 0) (29 0 22 0 nil 0) (27 0 26 0 nil 0) (1 0 26 1 nil 0) (27 0 28 0 nil 0) (27 0 29 0 nil 0) (28 0 29 1 nil 0) (22 0 30 0 nil 0) (31 0 30 1 nil 0) (30 0 32 0 nil 0))) nil 6.050003))
