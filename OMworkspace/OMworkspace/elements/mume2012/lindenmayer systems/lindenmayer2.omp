; OM File Header - Saved 2012/06/27 11:38:19
; (6.050003 :patc (om-make-point 10 10) (om-make-point 0 0) (om-make-point 1280 752) "" 183 0 "2012/06/18 17:23:03" "2012/06/26 18:46:09")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "lindenmayer2" (quote ((om-load-boxcall (quote lispfun) "SIXTH" (quote sixth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 1444 277) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ 6" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 1437 548) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6400) (6400) (6700) (6700) (7000) (7000) (6400) (6700) (6700) (6400) (6700) (6700) (6700) (7000) (7000) (7000) (7000) (7200) (7200) (7200) (7200) (7200) (7200) (7200) (6400) (6700) (6700) (6700) (7000) (7000) (6700) (7000) (7000) (7200) (7200) (7200) (7200) (7200) (7200) (7200))) :lonset (quote (500 2500 500 2500 500 2500 500 4500 4000 4500 6500 6000 6500 7500 7500 6500 5500 4500 2500 500 4000 4500 6000 6500 7500 8500 8000 9500 11000 9500 10500 14500 12500 15500 8500 11000 10000 13500 12500 16000 18500 21000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 292 1206) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote abstraction) "rel as score 6" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 1477 439) nil nil "&" "rel as score") (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 1621 349) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "FIFTH" (quote fifth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 1192 287) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ 5" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 1205 543) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6400) (6400) (6700) (6700) (7000) (7000) (6400) (6700) (6700) (6400) (6700) (6700) (7000) (7000) (7000) (7200) (7200) (7200) (7200) (7200) (6700) (7000) (7200) (7200))) :lonset (quote (500 2500 500 2500 500 2500 500 4500 4000 4500 6500 6000 7500 5500 4500 7500 2500 500 4000 7500 6500 11000 10500 10000 12500 15000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 291 1230) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote abstraction) "rel as score 5" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 1245 434) nil nil "&" "rel as score") (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 1389 344) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "FOURTH" (quote fourth) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 931 300) nil nil nil nil 1) (om-load-editor-box1 "CHORD-SEQ 4" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 939 549) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6400) (6400) (6700) (6700) (7000) (7000) (6400) (6700) (6700) (7000) (7200) (7200) (7200))) :lonset (quote (500 2500 500 2500 500 2500 500 4500 4000 7500 5500 500 4000 6500 9000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 291 1195) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote abstraction) "rel as score 4" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 979 440) nil nil "&" "rel as score") (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 1123 350) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 686 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 834 341) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote abstraction) "rel as score 3" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 690 431) nil nil "&" "rel as score") (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 650 540) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6400) (6700) (6400) (7000) (6700) (7200))) :lonset (quote (500 500 500 2500 500 4000 500 4000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 384 1230) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote lispfun) "LIST 3" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 376 662) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 508 277) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "rel as score 2" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 470 423) nil nil "&" "rel as score") (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 614 333) (om-make-point 21 30) 1 "1" nil) (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 436 542) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6400) (6700))) :lonset (quote (500 500 500 500)) :ldur (quote ((1000) (1000) (1000))) :lvel (quote ((100) (100) (100))) :loffset (quote ((0) (0) (0))) :lchan (quote ((1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 22) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 321 275) nil nil nil nil 1) (om-load-boxcall (quote bastype) "string 5" (quote string) (quote nil) (om-make-point 663 1078) (om-make-point 754 30) "if need to transform one element with consecutive element (in space or in time), simply use a time/space additional component" "\"if need to transform one element with consecutive element (in space or in time), simply use a time/space additional component\"" nil) (om-load-boxcall (quote bastype) "string 6" (quote string) (quote nil) (om-make-point 659 1011) (om-make-point 1013 30) "possible to build an l-system from initial state and final state, provided we know the number of recursion. Indeed, if a rule is used somewhere, it must be used everywhere !" "\"possible to build an l-system from initial state and final state, provided we know the number of recursion. Indeed, if a rule is used somewhere, it must be used everywhere !\"" nil) (om-load-boxcall (quote bastype) "string 4" (quote string) (quote nil) (om-make-point 669 799) (om-make-point 319 30) "A set of rule is just the union of those rule-relations" "\"A set of rule is just the union of those rule-relations\"" nil) (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 192 867) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 142 33) nil nil "&" "create Gecode manager") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 464 79) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "lindenmayer" (om-load-lisp-abspatch "lindenmayer" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp) $$  (let$$      ($       (glbScore (newGRelation gm 2))$       (pitches (first (createBoundedFullGroundRelation gm '((60 84)))))$       (onsets (first (createBoundedFullGroundRelation gm '((1 100)))))$       ;(duration (first (createBoundedFullGroundRelation gm '((1 4)))))$       $       (glbAxiom (newGRelation gm 2))$       (axiomVar nil)$$       (lubScore nil)$$$       ;different steps of the \"score lindenmayer evolution\"$       (scoreVar0 nil)$       (scoreVar1 nil)$       (scoreVar2 nil)$       (scoreVar3 nil)$       (scoreVar4 nil)$       (scoreVar5 nil)$       $       ;the different rules (here we only transform pitch to pitch, onset to onset, and pitch-onset to pitch-onset)$       ;glbs$       (glbUnaryRule (newGRelation gm 2)) ;pitch to pitch and onset to onset$       (glbBinaryRule (newGRelation gm 4)) ;note to note$$       ;lubs$       (lubRule1 (newGRelation gm 2))$       (lubRule2 (newGRelation gm 4))$       (lubRule3 nil)$       (lubRule4 nil)$       (lubRule5 nil)$$       ;the actual rules$       (Rule1Var nil)$       (Rule2Var nil)$       (Rule3Var nil)$       (Rule4Var nil)$       (Rule5Var nil)$$       (se nil)$$       ;different solution steps$       (solScoreRel0 nil)$       (solScoreRel1 nil)$       (solScoreRel2 nil)$       (solScoreRel3 nil)$       (solScoreRel4 nil)$       (solScoreRel5 nil)$     $$       ;auxilary ground relations$       (pitchPitch (newGRelation gm 2)) ; will link a pitch value with the same pitch value, used for note transformation$       (nNplus1 (newGRelation gm 2))$       (grRuleNote nil)$       $       ;auxilary ground relations$       (scoreVar0PT nil)$       (scoreVar0NT nil)$       (scoreVar1PT nil)$       (scoreVar1NT nil)$       (scoreVar2PT nil)$       (scoreVar2NT nil)$       (scoreVar3PT nil)$       (scoreVar3NT nil)$       (scoreVar4PT nil)$       (scoreVar4NT nil)$$       $       $$      )$$    $$$    ;the axiom$    (GRelation-AddTuple gm glbAxiom (newTuple gm '(1 60)))$    (setq axiomVar (newCPRelVar gm sp glbAxiom glbAxiom))$$    ;the score$    ;(setq lubScore (GRelation-Times gm (GRelation-Times gm duration onsets) pitches))$    (setq lubScore (GRelation-Times gm onsets pitches))$    (setq scoreVar0 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar1 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar2 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar3 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar4 (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar5 (newCPRelVar gm sp glbScore lubScore))$$    ;the rules$$    ;rule1 (on pitch)$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(60 60)))$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(60 64)))$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(60 67)))$$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(64 67)))$    (GRelation-AddTuple gm lubRule1 (newTuple gm '(64 70)))$    $    (GRelation-AddTuple gm lubRule1 (newTuple gm '(67 72))) $$    (setq Rule1Var (newCPRelVar gm sp lubRule1 lubRule1))$    $$    ;rule2 (on notes)$    ;auxilary ground relations$    ;;pitchPitch$    #|(loop for i from 60 to 72 do$          (GRelation-AddTuple gm pitchPitch (newTuple gm (list i i)))$          )$    ;;nNplus1$    (loop for i from 1 to 20 do$          (GRelation-AddTuple gm nNplus1 (newTuple gm (list i (+ i 1))))$          )$   $$    (setq grRuleNote (GRelation-Permute gm (GRelation-Times gm nNplus1 pitchPitch) '((1 2))))$$    |#$$    (setq grRuleNote (newGRelation gm 4))$$    (print \"before loop\")$$    (loop for i from 1 to 100 do$          (loop for j from 0 to 24 do $                (print (list i (+ 60 j) (+ i j) (+ 60 j)))$                (GRelation-AddTuple gm grRuleNote (newTuple gm (list i (+ 60 j) (+ i j) (+ 60 j))))$                )$          )$$    (print \"after loop\")$$    (setq Rule2Var (newCPRelVar gm sp grRuleNote grRuleNote))$ $    $    (print \"before constraints\")$$$$$    ;constraints$    ;the first score is the axiom$    (equalConstraint gm sp axiomVar scoreVar0)$$    ;the second var is created from the first one$    ;auxiliary variables$    (setq scoreVar0PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar0NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar0 1 Rule1Var scoreVar0PT)$    (followConstraint gm sp scoreVar0 2 Rule2Var scoreVar0NT)$    (unionConstraint gm sp scoreVar0PT scoreVar0NT scoreVar1)$$    ;the third score is created from the second one$    ;auxiliary variables$    (setq scoreVar1PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar1NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar1 1 Rule1Var scoreVar1PT)$    (followConstraint gm sp scoreVar1 2 Rule2Var scoreVar1NT)$    (unionConstraint gm sp scoreVar1PT scoreVar1NT scoreVar2)$    $    ;the fourth score is created from the third one$    ;auxiliary variables$    (setq scoreVar2PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar2NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar2 1 Rule1Var scoreVar2PT)$    (followConstraint gm sp scoreVar2 2 Rule2Var scoreVar2NT)$    (unionConstraint gm sp scoreVar2PT scoreVar2NT scoreVar3)$$    ;the fifth score is created from the fourth one$    ;auxiliary variables$    (setq scoreVar3PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar3NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar3 1 Rule1Var scoreVar3PT)$    (followConstraint gm sp scoreVar3 2 Rule2Var scoreVar3NT)$    (unionConstraint gm sp scoreVar3PT scoreVar3NT scoreVar4)$$    ;the sixth score is created from the fourth one$    ;auxiliary variables$    (setq scoreVar4PT (newCPRelVar gm sp glbScore lubScore))$    (setq scoreVar4NT (newCPRelVar gm sp glbScore lubScore))$    ;constraints$    (followConstraint gm sp scoreVar4 1 Rule1Var scoreVar4PT)$    (followConstraint gm sp scoreVar4 2 Rule2Var scoreVar4NT)$    (unionConstraint gm sp scoreVar4PT scoreVar4NT scoreVar5)$$$    $$$    (print \"after constraints\")$$$$$$$$    ;branching $    (branch gm sp scoreVar0)$    (branch gm sp scoreVar1)$$$    (print \"before print\")$    ;print$    ;(printSpace gm sp)$    $    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel0 (getVarInSpace gm sol1 scoreVar0))$          (setq solScoreRel1 (getVarInSpace gm sol1 scoreVar1))$          (setq solScoreRel2 (getVarInSpace gm sol1 scoreVar2))$          (setq solScoreRel3 (getVarInSpace gm sol1 scoreVar3))$          (setq solScoreRel4 (getVarInSpace gm sol1 scoreVar4))$          (setq solScoreRel5 (getVarInSpace gm sol1 scoreVar5))$  $     )$     ;else$     ()$    )$$    (print (list solScoreRel0 solScoreRel1 solScoreRel2 solScoreRel3 solScoreRel4 solScoreRel5))$     $$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil))) (om-make-point 381 184) nil nil "&" "lindenmayer") (om-load-boxcall (quote abstraction) "rel as score" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 619 282) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 560 243) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 299 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((7 0 1 0 nil 0) (0 0 1 1 nil 0) (9 0 3 1 nil 0) (1 0 3 2 nil 0) (2 0 3 6 nil 0) (3 0 5 0 nil 0) (4 0 6 0 nil 0) (6 0 7 0 nil 0) (6 0 8 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 280 420) nil nil "&" "rel as score") (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 424 330) (om-make-point 21 30) 1 "1" nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 259 539) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (500 1500)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 278 1200) (om-make-point 1280 752) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote bastype) "string 3" (quote string) (quote nil) (om-make-point 665 935) (om-make-point 527 30) "we can consider learning the rules from existing scores and appliying them on new data" "\"we can consider learning the rules from existing scores and appliying them on new data\"" nil) (om-load-boxcall (quote bastype) "string 2" (quote string) (quote nil) (om-make-point 666 882) (om-make-point 629 30) "What is new is that those rules can be undefined when we start the search !!! (if the relation is a variable)" "\"What is new is that those rules can be undefined when we start the search !!! (if the relation is a variable)\"" nil) (om-load-boxcall (quote bastype) "string" (quote string) (quote nil) (om-make-point 673 741) (om-make-point 449 30) "A rule is defined as a relation (or a tuple), used with a compose constraint" "\"A rule is defined as a relation (or a tuple), used with a compose constraint\"" nil))) (quote ((28 0 0 0 nil 0) (2 0 1 0 nil 0) (0 0 2 0 nil 0) (3 0 2 1 nil 0) (28 0 4 0 nil 0) (6 0 5 0 nil 0) (4 0 6 0 nil 0) (7 0 6 1 nil 0) (28 0 8 0 nil 0) (10 0 9 0 nil 0) (8 0 10 0 nil 0) (11 0 10 1 nil 0) (28 0 12 0 nil 0) (12 0 14 0 nil 0) (13 0 14 1 nil 0) (14 0 15 0 nil 0) (31 0 16 0 nil 0) (20 0 16 1 nil 0) (15 0 16 2 nil 0) (9 0 16 3 nil 0) (5 0 16 4 nil 0) (1 0 16 5 nil 0) (28 0 17 0 nil 0) (17 0 18 0 nil 0) (19 0 18 1 nil 0) (18 0 20 0 nil 0) (28 0 21 0 nil 0) (26 0 25 0 nil 0) (16 0 25 1 nil 0) (26 0 27 0 nil 0) (26 0 28 0 nil 0) (27 0 28 1 nil 0) (21 0 29 0 nil 0) (30 0 29 1 nil 0) (29 0 31 0 nil 0))) nil 6.050003))
