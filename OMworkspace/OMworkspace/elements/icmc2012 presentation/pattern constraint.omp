; OM File Header - Saved 2012/09/04 14:48:54
; (6.050003 :patc (om-make-point 118 10) (om-make-point 0 0) (om-make-point 1680 1006) "" 183 0 "2012/08/16 14:59:12" "2012/09/04 14:48:54")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "pattern constraint" (quote ((om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 485 46) (om-make-point 21 30) 4 "4" nil) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 399 46) (om-make-point 21 30) 4 "4" nil) (om-load-boxcall (quote abstraction) "create plus^3n" (om-load-lisp-abspatch "create plus^3n" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create plus\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm pitchBounds onsetBounds maxOffsetPitch maxOffsetOnset)$$  (let ($          (plusRel $           (createGroundRelFromTupleUUIDList gm $                        (createTupleUUIDListFromLispTupleList gm $                             (createBoundedPlus (list (min (first pitchBounds) (first onsetBounds)) (max (+ (second pitchBounds) maxOffsetPitch) (+ (second onsetBounds) maxOffsetOnset)) $                                                     )$                                                (list (min (first pitchBounds) (first onsetBounds)) (max (+ (second pitchBounds) maxOffsetPitch) (+ (second onsetBounds) maxOffsetOnset)) $                                                     )$                                 )$                          )$               )$           )$        $          (plus^3 nil)$          (plusRel3n nil)$          $$          )$$    (setq plus^3 (GRelation-Times gm plusRel plusRel))$$    (setq plusRel3n (GRelation-Permute gm plus^3 '((2 4) (2 3) (2 1))))$$  )$$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "PITCHBOUNDS" 0) (om-load-inputfun (quote input-funbox) "" "ONSETBOUNDS" nil) (om-load-inputfun (quote input-funbox) "" "MAXOFFSETPITCH" nil) (om-load-inputfun (quote input-funbox) "" "MAXOFFSETONSET" nil))) (om-make-point 442 164) nil nil "&" "create plus^3n") (om-load-boxcall (quote abstraction) "create patterns" (om-load-lisp-abspatch "create patterns" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create patterns\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$$$(lambda (gm)$$  (let $      ($       (patterns (newGRelation gm 3)); pitch | onset | index$       (patternsAndPatternsIds nil)$       )$$    $        (GRelation-AddTuple gm patterns (newTuple gm '(60 1 0)))$       $        (GRelation-AddTuple gm patterns (newTuple gm '(64 2 1)))$        $       $    $  $    $    ;return$    (setq chordsAndChordsIds (list patterns (first (createBoundedFullGroundRelation gm (list (list 0 1))))))$    )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 892 171) nil nil "&" "create patterns") (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 368 655) (om-make-point 1078 152) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6100))) :lonset (quote (1500 2500)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 0 -778) (om-make-point 1280 752) 0 1000 nil 14/25 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote bastype) "list 15" (quote list) (quote nil) (om-make-point 542 482) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote abstraction) "rel as score 3" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 491 97) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "FIRST 2" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 309 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((8 0 0 0 nil 0) (8 0 1 0 nil 0) (0 0 2 0 nil 0) (3 0 2 1 nil 0) (9 0 5 1 nil 0) (2 0 5 2 nil 0) (4 0 5 6 nil 0) (5 0 7 0 nil 0) (6 0 8 0 nil 0) (1 0 9 0 nil 0) (10 0 9 1 nil 0))) 6.050003 nil "" (om-make-point 0 -778) (om-make-point 1280 752)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 427 516) nil nil "&" "rel as score") (om-load-boxcall (quote lispfun) "LIST 13" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 387 836) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 11" (quote list) (quote nil) (om-make-point 861 5) (om-make-point 28 30) 20 "20" nil) (om-load-boxcall (quote bastype) "list 10" (quote list) (quote nil) (om-make-point 803 5) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "LIST 9" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 1) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 830 36) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 667 11) (om-make-point 28 30) 68 "68" nil) (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 578 13) (om-make-point 28 30) 60 "60" nil) (om-load-boxcall (quote lispfun) "LIST 5" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 48) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 72))) (om-make-point 617 57) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "possible pitch, onset" (om-load-lisp-abspatch "possible pitch, onset" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"possible pitch, onset and duration\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm pitchMinMax onsetMinMax)$$  (let ($        (pitches (first (createBoundedFullGroundRelation gm (list pitchMinMax))))$        (onsets (first (createBoundedFullGroundRelation gm (list onsetMinMax))))$   $        (toReturn nil)$        )$$    (setq toReturn (list pitches onsets))$$    )$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "PITCHMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "ONSETMINMAX" nil))) (om-make-point 697 175) nil nil "&" "possible pitch, onset") (om-load-boxcall (quote abstraction) "problem definition" (om-load-lisp-abspatch "problem definition" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"problem definition\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp plus3n shift pitchOnset patterns) $$$  (let$      ($       ;glbs and lubs$       ;glbs$       (glbScore (newGRelation gm 2))$       (lubScore (newFullGRelation gm 2))$       $       ;lubs$       (lubScore nil)$       $$       ;pitch, onset ground relations$       (pitches (first pitchOnset))$       (onsets (second pitchOnset))$   $$       ;pattern indexes rel$       (patternIndexes (second patterns))$     $       ;plus3nVar$       (plus3nVar (newCPRelVar gm sp plus3n plus3n))$$       ;patterns$       (patternsVar (newCPRelVar gm sp (first patterns) (first patterns)))$$       ;shift$       ;(shiftVar (newCPRelVar gm sp shift shift))$       ;(shiftVar (newCPRelVar gm sp (newGRelation gm 3) (newFullGRelation gm 3)))$       (shiftVar (newCPRelVar gm sp (newGRelation gm 3) shift))$       $$       ;score var$       (scoreVar nil)$$       ;patternShiftedVar$       (patternShiftedVar (newCPRelVar gm sp (newGRelation gm 3) (newFullGRelation gm 3))  )$       (permPatternShiftedVar (newCPRelVar gm sp (newGRelation gm 3) (newFullGRelation gm 3))  )$$       ;joinPS$       (joinPS (newCPRelVar gm sp (newGRelation gm 5) (newFullGRelation gm 5)))$       (permJoinPS (newCPRelVar gm sp (newGRelation gm 5) (newFullGRelation gm 5)))$$       (usedPIS (newCPRelVar gm sp (newGRelation gm 3) (newFullGRelation gm 3)))$$       (permUsedPIS (newCPRelVar gm sp (newGRelation gm 3) (newFullGRelation gm 3)))$       $      ;search engine$      (se nil)$$      ;solution$      (sol1 nil)$$      (solScoreRel nil)$$      (A nil)$      (B nil)$      (C nil)$$     )$$    ;(debugSpace gm sp)$    $$    ;scores$    ;(setq lubScore (GRelation-Times gm pitches (GRelation-Times gm onsets durations)))$$    (setq scoreVar (newCPRelVar gm sp glbScore lubScore))$$    (print \"Before constraints\")$    ;constraints$$    ;put the shifts next to the information to be shifted$    (joinConstraint gm sp patternsVar 1 shiftVar joinPS)$    ;(permutationConstraint gm sp joinPS permJoinPS '((1 2) (0 1)))$    (permutationConstraint gm sp joinPS permJoinPS '((2 3) (3 4)))$$    (print \"1\")$$    ;compute the shift$    (followConstraint gm sp permJoinPS 4 plus3nVar patternShiftedVar)$    (permutationConstraint gm sp patternShiftedVar permPatternShiftedVar '((1 2) (0 1)))$    $    (print \"2\")$$    ;get the patterns used in the score$    (confluentJoinConstraint gm sp scoreVar 2 permPatternShiftedVar usedPIS)$$    (print \"3\")$$    ;permutation of usedPIS$    (permutationConstraint gm sp usedPIS permUsedPIS '((0 2) (0 1)))$$    (print \"4\")$$    ;enforce that the score only use some patterns$    (projectionConstraint gm sp 2 permUsedPIS scoreVar)$    $    (print \"5\")$$    ;(printSpace gm sp)$$    ;branching $    (branch gm sp scoreVar)$    $    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    $    (print \"Search !\")$$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel (getVarInSpace gm sol1 scoreVar))$$          (setq A (getVarInSpace gm sol1 patternsVar))$          (setq A (getVarInSpace gm sol1 shiftVar))$          (setq A (getVarInSpace gm sol1 joinPS))$$          (setq A (getVarInSpace gm sol1 permJoinPS))$$          (setq A (getVarInSpace gm sol1 patternShiftedVar))$          $          (setq A (getVarInSpace gm sol1 permPatternShiftedVar))$          (setq A (getVarInSpace gm sol1 usedPIS))$$          (setq A (getVarInSpace gm sol1 permUsedPIS))$$          $          $          $          $         $     )$     ;else$     ()$    )$$   $$    (print solScoreRel)$)$$$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil) (om-load-inputfun (quote input-funbox) "" "PLUS3N" nil) (om-load-inputfun (quote input-funbox) "" "SHIFT" nil) (om-load-inputfun (quote input-funbox) "" "PITCHONSET" nil) (om-load-inputfun (quote input-funbox) "" "PATTERNS" nil))) (om-make-point 410 352) nil nil "&" "problem definition") (om-load-boxcall (quote abstraction) "create Shift" (om-load-lisp-abspatch "create Shift" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $  $  (let $      ($       ;(shift (newFullGRelation gm 3));  indexPattern | ShiftPitch | ShiftOnset$       (shift (newGRelation gm 3))$       )$$    (GRelation-AddTuple gm shift (newTuple gm '(0 1 2)))$    (GRelation-AddTuple gm shift (newTuple gm '(1 3 4)))$    $    ;return$    (setq shift shift)$$)$  $$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 583 168) nil nil "&" "create Shift") (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 256 930) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 291 198) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 128 42) nil nil "&" "create Gecode manager"))) (quote ((19 0 2 0 nil 0) (13 0 2 1 nil 0) (10 0 2 2 nil 0) (1 0 2 3 nil 0) (0 0 2 4 nil 0) (19 0 3 0 nil 0) (6 0 4 0 nil 0) (15 0 6 0 nil 0) (5 0 6 1 nil 0) (4 0 7 0 nil 0) (9 0 10 0 nil 0) (8 0 10 1 nil 0) (12 0 13 0 nil 0) (11 0 13 1 nil 0) (19 0 14 0 nil 0) (13 0 14 1 nil 0) (10 0 14 2 nil 0) (19 0 15 0 nil 0) (18 0 15 1 nil 0) (2 0 15 2 nil 0) (16 0 15 3 nil 0) (14 0 15 4 nil 0) (3 0 15 5 nil 0) (19 0 16 0 nil 0) (19 0 17 0 nil 0) (7 0 17 1 nil 0) (19 0 18 0 nil 0))) nil 6.050003))
