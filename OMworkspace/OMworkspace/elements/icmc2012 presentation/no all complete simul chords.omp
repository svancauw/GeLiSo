; OM File Header - Saved 2012/09/04 14:48:51
; (6.050003 :patc (om-make-point 118 10) (om-make-point 0 0) (om-make-point 1280 752) "" 183 0 "2012/08/09 17:52:41" "2012/08/10 15:54:09")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "no all complete simul chords" (quote ((om-load-boxcall (quote lispfun) "LIST 12" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 0) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 20))) (om-make-point 507 69) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "create chords" (om-load-lisp-abspatch "create chords" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create patterns\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$$$(lambda (gm pitchbounds)$$  (let $      ($       (chords (newGRelation gm 2));$       (currentChordIndex 0)$       (chordsAndChordsIds nil)$       )$$    (loop for x from (first pitchbounds) to (second pitchbounds) do$        $        ;major chords   $        (GRelation-AddTuple gm chords (newTuple gm (list currentChordIndex x)))$        (GRelation-AddTuple gm chords (newTuple gm (list currentChordIndex (+ 4 x))))$        (GRelation-AddTuple gm chords (newTuple gm (list currentChordIndex (+ 7 x))))$        (incf currentChordIndex)$        ;minor chords$        (GRelation-AddTuple gm chords (newTuple gm (list currentChordIndex x)))$        (GRelation-AddTuple gm chords (newTuple gm (list currentChordIndex (+ 3 x))))$        (GRelation-AddTuple gm chords (newTuple gm (list currentChordIndex (+ 7 x))))$        (incf currentChordIndex)$    )$    $   $  $    (print currentChordIndex)$$$    $    $    ;return$    (setq chordsAndChordsIds (list chords (first (createBoundedFullGroundRelation gm (list (list 0 (- currentChordIndex 1)))))))$    )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "PITCHBOUNDS" nil))) (om-make-point 1102 188) nil nil "&" "create chords") (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 370 684) (om-make-point 576 126) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6100) (6100) (6200) (6300) (6200) (6300) (6400) (6500) (6600) (6700) (6600) (6700))) :lonset (quote (0 0 500 0 0 500 500 500 500 0 0 500 500 500)) :ldur (quote ((500) (500) (500) (500) (500) (500) (500) (500) (500) (500) (500) (500) (500))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 278 1200) (om-make-point 1280 752) 0 1000 nil 14/25 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote bastype) "list 15" (quote list) (quote nil) (om-make-point 542 482) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote abstraction) "rel as score 3" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 491 97) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 497 307) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "FIRST 2" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 309 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 573 333) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 100 "100" nil))) (quote ((11 0 0 0 nil 0) (11 0 1 0 nil 0) (11 0 2 0 nil 0) (0 0 3 0 nil 0) (4 0 3 1 nil 0) (1 0 6 0 nil 0) (5 0 6 1 nil 0) (12 0 8 1 nil 0) (3 0 8 2 nil 0) (6 0 8 3 nil 0) (7 0 8 6 nil 0) (8 0 10 0 nil 0) (9 0 11 0 nil 0) (2 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 0 0) (om-make-point 1920 1156)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 426 572) nil nil "&" "rel as score") (om-load-boxcall (quote lispfun) "LIST 13" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 387 836) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 11" (quote list) (quote nil) (om-make-point 971 27) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote bastype) "list 10" (quote list) (quote nil) (om-make-point 904 21) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "LIST 9" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 1) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 919 65) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 756 13) (om-make-point 28 30) 68 "68" nil) (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 668 21) (om-make-point 28 30) 60 "60" nil) (om-load-boxcall (quote lispfun) "LIST 5" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 48) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 72))) (om-make-point 741 87) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "possible pitch, onset and duration, onsetNoDur" (om-load-lisp-abspatch "possible pitch, onset and duration, onsetNoDur" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"possible pitch, onset and duration\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm pitchMinMax onsetMinMax durationMinMax)$$  (let ($        (pitches (first (createBoundedFullGroundRelation gm (list pitchMinMax))))$        (onsets (first (createBoundedFullGroundRelation gm (list onsetMinMax))))$        (duration (first (createBoundedFullGroundRelation gm (list durationMinMax))))$        (onsetsNoDur (first (createBoundedFullGroundRelation gm (list (list (first onsetMinMax) (+ (second onsetMinMax) (- (second durationMinMax) 1)))))))$        (toReturn nil)$        )$$    (setq toReturn (list pitches onsets duration onsetsNoDur))$$    )$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "PITCHMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "ONSETMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "DURATIONMINMAX" nil))) (om-make-point 790 202) nil nil "&" "possible pitch, onset and duration, onsetNoDur") (om-load-boxcall (quote abstraction) "problem definition" (om-load-lisp-abspatch "problem definition" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"problem definition\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp fsc tduration pitchOnsetDuration Chords) $$$  (let$      ($       ;glbs and lubs$       ;glbs$       (glbScore (newGRelation gm 3))$       (glbScoreNoDur (newGRelation gm 2))$       $       $       ;lubs$       (lubScore nil)$       (lubScoreNoDur nil)$       $$       ;pitch, onset and duration ground relations$       (pitches (first pitchOnsetDuration))$       (onsets (second pitchOnsetDuration))$       (durations (third pitchOnsetDuration))$       (onsetsNoDur (fourth pitchOnsetDuration))$$       ;chord indexes rel$       (chordIndexes (second Chords))$     $       ;fscvar$       (fscVar (newCPRelVar gm sp (first fsc) (first fsc)))$$       ;tduration$       (tdurVar (newCPRelVar gm sp tduration tduration))$$       ;chords$       (chordsVar (newCPRelVar gm sp (first Chords) (first Chords)))$$       ;iovar$       (ioVar nil)$$       ;emptyvar$       (emptyVar nil)$$       ;score var$       (scoreVar nil)$       (scoreNoDurVar nil)$       $      ;search engine$      (se nil)$$      ;solution$      (sol1 nil)$$      (solScoreRel nil)$      (A nil)$      (B nil)$      (C nil)$$     )$    $$    ;scores$    (setq lubScore (GRelation-Times gm pitches (GRelation-Times gm onsets durations)))$    (setq lubScoreNoDur (GRelation-Times gm pitches onsetsNoDur))$$    (setq scoreVar (newCPRelVar gm sp glbScore lubScore))$    (setq scoreNoDurVar (newCPRelVar gm sp glbScoreNoDur lubScoreNoDur))$$    ;link chord index | onset$    (setq ioVar (newCPRelVar gm sp glbScoreNoDur (GRelation-Times gm chordIndexes onsets)))$$     ;emptyvar$    (setq emptyvar (newCPRelVar gm sp glbScoreNoDur glbScoreNoDur))$$    (print \"Before constraints\")$    ;constraints$$    ;create a new score from the original one in which the notes with duration n are now n consecutive notes of duration 1$    (followConstraint gm sp scoreVar 2 tdurVar scoreNoDurVar)$$    ;link the chords index with the onset where a full score is played (heard)$    (confluentComposeConstraint gm sp chordsVar 1 scoreNoDurVar ioVar)$$$    ;enfore that the link, between chords heard at a given onset and chords that are forbidden to be together, is empty$    (confluentComposeConstraint gm sp fscVar 1 ioVar emptyVar)$    $    (printSpace gm sp)$$    ;branching $    (branch gm sp scoreVar)$    $    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    $    (print \"Search !\")$$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel (getVarInSpace gm sol1 scoreVar))$          (setq A (getVarInSpace gm sol1 scoreNoDurVar))$          (setq B (getVarInSpace gm sol1 ioVar))$          (setq C (getVarInSpace gm sol1 fscVar))$     )$     ;else$     ()$    )$$    (printSpace gm sol1)$$    (print solScoreRel)$)$$$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil) (om-load-inputfun (quote input-funbox) "" "FSC" nil) (om-load-inputfun (quote input-funbox) "" "TDURATION" nil) (om-load-inputfun (quote input-funbox) "" "PITCHONSETDURATION" nil) (om-load-inputfun (quote input-funbox) "" "CHORDS" nil))) (om-make-point 410 352) nil nil "&" "problem definition") (om-load-boxcall (quote abstraction) "create TDuration" (om-load-lisp-abspatch "create TDuration" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm xbounds ybounds) $  $  (let $      ($       (tduration (newGRelation gm 3));  X | Y | Z$       )$$    (loop for x from (first xbounds) to (second xbounds) do$        (loop for y from (first ybounds) to (second ybounds) do$              (loop for z from x to (+ x (- y 1)) do$                    (GRelation-AddTuple gm tduration (newTuple gm (list x y z)))$              )$        )$    )$    $$    ;return$    (setq tduration tduration)$$)$  $$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "XBOUNDS" nil) (om-load-inputfun (quote input-funbox) "" "YBOUNDS" nil))) (om-make-point 640 201) nil nil "&" "create TDuration") (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 525 18) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 485 21) (om-make-point 21 30) 0 "0" nil) (om-load-boxcall (quote abstraction) "create FSCChordSets" (om-load-lisp-abspatch "create FSCChordSets" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create patterns\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$$$(lambda (gm)$$  (let $      ($       (fsc (newGRelation gm 2)); $       (fscAndFscIds nil)$       )$$$    ;link between setIndexOfFSC and Chords $$    ;set 1$    (loop for x from 0 to 0 do$        $          (GRelation-AddTuple gm fsc (newTuple gm (list 1 x)))$          $        $    )$   $$$    $    $    ;return$    (setq fscAndFscIds (list fsc (first (createBoundedFullGroundRelation gm '((1 1))))))$    )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 501 200) nil nil "&" "create FSCChordSets") (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 256 930) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 292 203) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 128 42) nil nil "&" "create Gecode manager"))) (quote ((16 0 0 0 nil 0) (15 0 0 1 nil 0) (20 0 1 0 nil 0) (11 0 1 1 nil 0) (4 0 2 0 nil 0) (13 0 4 0 nil 0) (3 0 4 1 nil 0) (2 0 5 0 nil 0) (7 0 8 0 nil 0) (6 0 8 1 nil 0) (10 0 11 0 nil 0) (9 0 11 1 nil 0) (20 0 12 0 nil 0) (11 0 12 1 nil 0) (0 0 12 2 nil 0) (8 0 12 3 nil 0) (20 0 13 0 nil 0) (19 0 13 1 nil 0) (17 0 13 2 nil 0) (14 0 13 3 nil 0) (12 0 13 4 nil 0) (1 0 13 5 nil 0) (20 0 14 0 nil 0) (0 0 14 1 nil 0) (8 0 14 2 nil 0) (20 0 17 0 nil 0) (20 0 18 0 nil 0) (5 0 18 1 nil 0) (20 0 19 0 nil 0))) nil 6.050003))
