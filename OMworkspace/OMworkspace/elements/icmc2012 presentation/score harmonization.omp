; OM File Header - Saved 2012/09/04 14:48:54
; (6.050003 :patc (om-make-point 118 10) (om-make-point 0 -778) (om-make-point 1280 752) "" 183 0 "2012/08/10 16:07:00" "2012/08/16 10:56:12")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "score harmonization" (quote ((om-load-boxcall (quote bastype) "string" (quote string) (quote nil) (om-make-point 756 378) (om-make-point 817 30) "One problem with this constraint is that if there is just one note that is not part of the chord, the chord is not identied !!! (see the example)" "\"One problem with this constraint is that if there is just one note that is not part of the chord, the chord is not identied !!! (see the example)\"" nil) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 795 109) (om-make-point 21 30) 2 "2" nil) (om-load-boxcall (quote lispfun) "LIST 12" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 0) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 20))) (om-make-point 507 69) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "create chords" (om-load-lisp-abspatch "create chords" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create patterns\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$$$(lambda (gm pitchbounds)$$  (let $      ($       (chords (newGRelation gm 2));$       (currentChordIndex 0)$       (chordsAndChordsIds nil)$       )$$    (loop for x from (first pitchbounds) to (second pitchbounds) do$        $        ;major chords   $        (GRelation-AddTuple gm chords (newTuple gm (list x currentChordIndex)))$        (GRelation-AddTuple gm chords (newTuple gm (list (+ 4 x) currentChordIndex)))$        (GRelation-AddTuple gm chords (newTuple gm (list (+ 7 x) currentChordIndex)))$        (incf currentChordIndex)$        ;minor chords$        (GRelation-AddTuple gm chords (newTuple gm (list x currentChordIndex)))$        (GRelation-AddTuple gm chords (newTuple gm (list (+ 3 x) currentChordIndex)))$        (GRelation-AddTuple gm chords (newTuple gm (list (+ 7 x) currentChordIndex)))$        (incf currentChordIndex)$    )$    $   $  $    (print currentChordIndex)$$$    $    $    ;return$    (setq chordsAndChordsIds (list chords (first (createBoundedFullGroundRelation gm (list (list 0 (- currentChordIndex 1)))))))$    )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "PITCHBOUNDS" nil))) (om-make-point 868 193) nil nil "&" "create chords") (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 370 684) (om-make-point 576 126) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000) (6100) (6400) (6700))) :lonset (quote (0 0 0 0 0)) :ldur (quote ((1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) "&" nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 278 1200) (om-make-point 1280 752) 0 1000 nil 14/25 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil) (om-load-boxcall (quote bastype) "list 15" (quote list) (quote nil) (om-make-point 542 482) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote abstraction) "rel as score 3" (om-load-patch-abs1 "rel as score" (quote ((om-load-boxcall (quote lispfun) "SECOND" (quote second) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 491 97) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "THIRD" (quote third) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 497 307) nil nil nil nil 1) (om-load-boxcall (quote lispfun) "FIRST 2" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 309 239) nil nil nil nil 1) (om-load-boxcall (quote genfun) "OM* 3" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 591 167) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 642 116) (om-make-point 35 30) 500 "500" nil) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 670 231) (om-make-point 35 30) 100 "100" nil) (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 573 333) nil nil nil nil 1) (om-load-boxin "channel" 1 (om-make-point 862 301) "" "channel" nil nil) (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 396 417) (om-make-point 130 70) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000))) :lonset (quote (0 1000)) :ldur (quote ((1000))) :lvel (quote ((100))) :loffset (quote ((0))) :lchan (quote ((1))) :legato 0)))) (load-port-info newobj (quote ((0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.050003 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (palette-mode scale show-stems obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list 0 nil (quote t) 1 0 (om-make-point 311 -671) (om-make-point 370 280) 0 1000 nil 1 (quote :midishare) 0 nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) nil nil nil nil) (om-load-boxin "input" 0 (om-make-point 371 48) "" nil nil nil) (om-load-boxout "output" 0 (om-make-point 353 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil) (om-load-boxcall (quote abstraction) "get score param from rel" (om-load-lisp-abspatch "get score param from rel" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"get score param from rel\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (scoreRel)$  (let$      ($       (scoreParam (getScoreParamFromSol scoreRel))$       )$$       (print scoreParam)$  )$$)") (quote ((om-load-inputfun (quote input-funbox) "" "SCOREREL" nil))) (om-make-point 317 136) nil nil "&" "get score param from rel") (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 373 298) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 424 247) (om-make-point 35 30) 500 "500" nil))) (quote ((11 0 0 0 nil 0) (11 0 1 0 nil 0) (11 0 2 0 nil 0) (0 0 3 0 nil 0) (4 0 3 1 nil 0) (1 0 6 0 nil 0) (5 0 6 1 nil 0) (6 0 8 1 nil 0) (12 0 8 2 nil 0) (3 0 8 3 nil 0) (7 0 8 6 nil 0) (8 0 10 0 nil 0) (9 0 11 0 nil 0) (2 0 12 0 nil 0) (13 0 12 1 nil 0))) 6.050003 nil "" (om-make-point 0 0) (om-make-point 1920 1156)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil))) (om-make-point 426 573) nil nil "&" "rel as score") (om-load-boxcall (quote lispfun) "LIST 13" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 387 836) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 11" (quote list) (quote nil) (om-make-point 971 27) (om-make-point 21 30) 4 "4" nil) (om-load-boxcall (quote bastype) "list 10" (quote list) (quote nil) (om-make-point 904 21) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote lispfun) "LIST 9" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 1) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 919 65) nil nil nil nil 1) (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 756 13) (om-make-point 28 30) 68 "68" nil) (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 668 21) (om-make-point 28 30) 60 "60" nil) (om-load-boxcall (quote lispfun) "LIST 5" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" 48) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 72))) (om-make-point 704 82) nil nil nil nil 1) (om-load-boxcall (quote abstraction) "possible pitch, onset and duration, DurMin" (om-load-lisp-abspatch "possible pitch, onset and duration, DurMin" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"possible pitch, onset and duration\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm pitchMinMax onsetMinMax durationMinMax durMin)$$  (let ($        (pitches (first (createBoundedFullGroundRelation gm (list pitchMinMax))))$        (onsets (first (createBoundedFullGroundRelation gm (list onsetMinMax))))$        (duration (first (createBoundedFullGroundRelation gm (list durationMinMax))))$        (durationMin (first (createBoundedFullGroundRelation gm (list (list durMin (second durationMinMax))))))$        (toReturn nil)$        )$$    (setq toReturn (list pitches onsets duration durationMin))$$    )$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "PITCHMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "ONSETMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "DURATIONMINMAX" nil) (om-load-inputfun (quote input-funbox) "" "DURMIN" nil))) (om-make-point 502 195) nil nil "&" "possible pitch, onset and duration, DurMin") (om-load-boxcall (quote abstraction) "problem definition" (om-load-lisp-abspatch "problem definition" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"problem definition\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm sp pitchOnsetDuration Chords) $$$  (let$      ($       ;glbs and lubs$       ;glbs$       (glbScore (newGRelation gm 3))$       $       $       ;lubs$       (lubScore nil)$       (lubHarmScore nil)$       (lubODMin nil)$       $$       ;pitch, onset and duration ground relations$       (pitches (first pitchOnsetDuration))$       (onsets (second pitchOnsetDuration))$       (durations (third pitchOnsetDuration))$       (durationMin (fourth pitchOnsetDuration))$$       ;chord indexes rel$       (chordIndexes (second Chords))$     $       ;chords$       (chordsVar (newCPRelVar gm sp (first Chords) (first Chords)))$$       ;score var$       (scoreVar nil)$       (scorePrimeVar nil)$       (harmScoreVar nil)$       $       $       (onsetXDurMinVar nil)$       $      ;search engine$      (se nil)$$      ;solution$      (sol1 nil)$$      (solScoreRel nil)$      (A nil)$      (B nil)$      (C nil)$      (D nil)$$$     $$     )$$    (setq lubHarmScore (GRelation-Times gm (GRelation-Times gm onsets durations) chordIndexes))$    (setq harmScoreVar (newCPRelVar gm sp glbScore lubHarmScore))$    $    (GRelation-AddTuple gm glbScore (newTuple gm '(0 2 60)))$    (GRelation-AddTuple gm glbScore (newTuple gm '(0 2 64)))$    (GRelation-AddTuple gm glbScore (newTuple gm '(0 2 67)))$    (GRelation-AddTuple gm glbScore (newTuple gm '(0 2 61)))$$    (setq lubScore glbScore)$$    ;scores    $    ;(setq lubScore (GRelation-Times gm (GRelation-Times gm onsets durations) pitches))$    $    $    $    (setq lubODMin (GRelation-Times gm onsets durationMin) )$$    (setq onsetXDurMinVar (newCPRelVar gm sp lubODMin lubODMin))$$    (setq scoreVar (newCPRelVar gm sp glbScore lubScore))$    (print \"4\")$    (setq scorePrimeVar (newCPRelVar gm sp glbScore lubScore))$$    (print \"5\")$$    $$    (print \"6\")$$    (print \"Before constraints\")$    ;constraints$$$    (print \"Before constraint 1\")$    ;keep the \"useful\" information to harmonize $    (joinConstraint gm sp onsetXDurMinVar 2 scoreVar scorePrimeVar)$    $$    (print \"Before constraint 2\")$    ;harmonize$    (confluentComposeConstraint gm sp scorePrimeVar 1 chordsVar harmScoreVar)$$    (print \"After constraints\")$$    (printSpace gm sp)$$    ;branching $    (branch gm sp scoreVar)$    (branch gm sp harmScoreVar)$$    ;search engine$    (setq se (newSearchEngine gm sp 0))$$    $    (print \"Search !\")$$$    ;get a solution$    (setq sol1 (nextSolution gm sp se))$$    (if (string/= sol1 \"0\");if there is a solution$    ;then$    ;get a var from the solution space$     (progn$          (setq solScoreRel (getVarInSpace gm sol1 scoreVar))$          (setq A (getVarInSpace gm sol1 onsetXDurMinVar))$          (setq D (getVarInSpace gm sol1 scorePrimeVar))$          (setq B (getVarInSpace gm sol1 chordsVar))$          (setq C (getVarInSpace gm sol1 harmScoreVar))$     )$     ;else$     ()$    )$$    (printSpace gm sol1)$$    (print solScoreRel)$)$$$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "SP" nil) (om-load-inputfun (quote input-funbox) "" "PITCHONSETDURATION" nil) (om-load-inputfun (quote input-funbox) "" "CHORDS" nil))) (om-make-point 410 352) nil nil "&" "problem definition") (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 525 18) (om-make-point 21 30) 1 "1" nil) (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 485 21) (om-make-point 21 30) 0 "0" nil) (om-load-boxcall (quote abstraction) "quit" (om-load-lisp-abspatch "quit" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm in)$$(print \"Start quit\")$;quit$(quitGecode gm)$$)") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil) (om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 256 930) nil nil nil "quit") (om-load-boxcall (quote abstraction) "create space" (om-load-lisp-abspatch "create space" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"create space\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (gm) $$;space$(setq sp (newSpace gm))$$)$") (quote ((om-load-inputfun (quote input-funbox) "" "GM" nil))) (om-make-point 292 203) nil nil "&" "create space") (om-load-boxcall (quote abstraction) "create Gecode manager" (om-load-lisp-abspatch "create Gecode manager" 6.050003 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (in) $$(print \"gm created\")$$(load \"/Users/saschavancauwelaert/Documents/EPL/PhD/code/GeLiSo_interface/GeLiSo/lispsources/load.lisp\")$$(setq endpoint_receive '(\"127.0.0.1\" 2222))$(setq endpoint_send '(\"127.0.0.1\" 3333))$		$;create the gecode manager and connect the sockets$(setq gm (make-instance 'GecodeManager :sender (createSocket (first endpoint_send) (second endpoint_send)) :receiver (createSocket (first endpoint_receive) (second endpoint_receive))))$$$)") (quote ((om-load-inputfun (quote input-funbox) "" "IN" nil))) (om-make-point 128 42) nil nil "&" "create Gecode manager"))) (quote ((17 0 2 0 nil 0) (16 0 2 1 nil 0) (20 0 3 0 nil 0) (13 0 3 1 nil 0) (6 0 4 0 nil 0) (15 0 6 0 nil 0) (5 0 6 1 nil 0) (4 0 7 0 nil 0) (9 0 10 0 nil 0) (8 0 10 1 nil 0) (12 0 13 0 nil 0) (11 0 13 1 nil 0) (20 0 14 0 nil 0) (13 0 14 1 nil 0) (2 0 14 2 nil 0) (10 0 14 3 nil 0) (1 0 14 4 nil 0) (20 0 15 0 nil 0) (19 0 15 1 nil 0) (14 0 15 2 nil 0) (3 0 15 3 nil 0) (20 0 18 0 nil 0) (7 0 18 1 nil 0) (20 0 19 0 nil 0))) nil 6.050003))
